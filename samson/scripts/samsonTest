#!/bin/bash

function setup_test_vars
{
    HAVE_DELILAH_INIT=0
    HAVE_SHELL_INIT=0
    HAVE_COMMAND=0
    HAVE_SCRIPT=0
    HAVE_SHELL=0
    INIT_DELILAH_ERROR=0
    INIT_SHELL_ERROR=0
    MULTIPLE_TESTS=0
    TEST_FAILED=0

    TEST_BASENAME=$(echo $TEST_FILE | sed 's/\.test//')
    TEST_NAME=$(sed -n '/--NAME--/,/^--/p' $TEST_FILE  | grep -v "^--")

    #Extract the delilah init script
    if [ $(grep "\-\-DELILAH\-INIT\-\-" $TEST_FILE | wc -l) -eq 1 ]; then
        TEST_DELILAH_INIT=${TEST_BASENAME}.delilah_init
        sed -n '/--DELILAH-INIT--/,/^--/p' $TEST_FILE  | grep -v "^--" > $TEST_DELILAH_INIT
        HAVE_DELILAH_INIT=1
    fi

    #Extract the shell init script
    if [ $(grep "\-\-SHELL\-INIT\-\-" $TEST_FILE | wc -l) -eq 1 ]; then
        TEST_SHELL_INIT=${TEST_BASENAME}.sh_init
        sed -n '/--SHELL-INIT--/,/^--/p' $TEST_FILE  | grep -v "^--" > $TEST_SHELL_INIT
        HAVE_SHELL_INIT=1
    fi

    #Extract the delilah test command
    if [ $(grep "\-\-COMMAND\-\-" $TEST_FILE | wc -l) -eq 1 ]; then
        TEST_COMMAND=$(sed -n '/--COMMAND--/,/^--/p' $TEST_FILE  | grep -v "^--")
        HAVE_COMMAND=1
    fi

    #Extract the delilah test script
    if [ $(grep "\-\-SCRIPT\-\-" $TEST_FILE | wc -l) -eq 1 ]; then
        TEST_DELILAH_SCRIPT=${TEST_BASENAME}.txt
        sed -n '/--SCRIPT--/,/^--/p' $TEST_FILE  | grep -v "^--"  > $TEST_DELILAH_SCRIPT
        HAVE_SCRIPT=1
    fi

    #Extract the shell script
    if [ $(grep "\-\-SHELL\-\-" $TEST_FILE | wc -l) -eq 1 ]; then
        TEST_SHELL_SCRIPT=${TEST_BASENAME}.sh
        sed -n '/--SHELL--/,/^--/p' $TEST_FILE  | grep -v "^--" > $TEST_SHELL_SCRIPT
        HAVE_SHELL=1
    fi

    #Generate the canon file
    if [ $(grep "\-\-EXPECT\-\-" $TEST_FILE | wc -l) -eq 1 ]; then
        TEST_EXPECT=${TEST_BASENAME}.expect
        sed -n '/--EXPECT--/,/^--/p' $TEST_FILE  | grep -v "^--" > $TEST_EXPECT
    else
        echo "ERROR: $TEST_FILE is missing an --EXPECT-- section"
        exit 1
    fi
    TEST_DIFF=${TEST_BASENAME}.diff
    TEST_OUTPUT=${TEST_BASENAME}.out
    TEST_OUTPUT_COMPLETE=${TEST_BASENAME}.out.complete

    if [ $HAVE_COMMAND -eq 0 -a $HAVE_SHELL -eq 0 -a $HAVE_SCRIPT -eq 0 ]; then
        echo "ERROR: $TEST_FILE is missing a test"
        exit 1
    fi

    if [ $HAVE_COMMAND -eq 1 ]; then
        if [ $HAVE_SHELL -eq 1 -o $HAVE_SCRIPT -eq 1 ]; then
            MULTIPLE_TESTS=1
        fi
    fi
    if [ $HAVE_SHELL -eq 1 ]; then
        if [ $HAVE_COMMAND -eq 1 -o $HAVE_SCRIPT -eq 1 ]; then
            MULTIPLE_TESTS=1
        fi
    fi
    if [ $HAVE_SCRIPT -eq 1 ]; then
        if [ $HAVE_COMMAND -eq 1 -o $HAVE_SHELL -eq 1 ]; then
            MULTIPLE_TESTS=1
        fi
    fi
    if [ $MULTIPLE_TESTS -eq 1 ]; then
        echo "Only one test type of --COMMAND--, --SCRIPT-- or --SHELL-- allowed"
        exit 1
    fi
}

function execute_test
{
    echo "RUNNING: $TEST_NAME ( $TEST_FILE )"

    # ------------------------------------------------ 
    # Initialize the test
    # ------------------------------------------------ 
    if [ $HAVE_DELILAH_INIT -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Initializing test using delilah"
            cat  `basename $TEST_DELILAH_INIT`
        fi
        pushd  `dirname $TEST_DELILAH_INIT` > /dev/null
        delilah ${SAMSON_LOG_LEVELS} -f `basename $TEST_DELILAH_INIT` ${SAMSON_TEST_HOST}:${SAMSON_WORKER_PORT_ENV} 2> `basename $TEST_DELILAH_INIT`.stderr > `basename $TEST_DELILAH_INIT`.stdout
        if [ $? -ne 0 ]; then
            INIT_DELILAH_ERROR=1
        fi
        popd > /dev/null
    fi

    if [ $HAVE_SHELL_INIT -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Initializing test using bash"
            cat $TEST_SHELL_INIT
        fi
        bash -x $TEST_SHELL_INIT 2> $TEST_SHELL_INIT.stderr > $TEST_SHELL_INIT.stdout
        if [ $? -ne 0 ]; then
            INIT_SHELL_ERROR=1
        fi
    fi

    # ------------------------------------------------
    # Execute a single delilah command
    # ------------------------------------------------
    if [ $HAVE_COMMAND -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Executing test command - ${TEST_COMMAND}"
        fi
        delilah ${SAMSON_LOG_LEVELS} ${SAMSON_TEST_HOST}:${SAMSON_WORKER_PORT_ENV} -command "$TEST_COMMAND"  > $TEST_OUTPUT_COMPLETE 2>/dev/null
        grep -v "^[MEWT]:" $TEST_OUTPUT_COMPLETE > $TEST_OUTPUT 2>/dev/null
    fi

    # ------------------------------------------------
    # Execute delilah script
    # ------------------------------------------------
    if [ $HAVE_SCRIPT -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Executing test using delilah"
        fi
        if [ -f  $TEST_OUTPUT ]; then
            rm -f  $TEST_OUTPUT
        fi
        if [ -f  $TEST_OUTPUT_COMPLETE ]; then
            rm -f  $TEST_OUTPUT_COMPLETE
        fi
        IFS="
"
        for command in $(awk '{print $0}' $TEST_DELILAH_SCRIPT)
        do
            if [ $TEST_VERBOSE -eq 1 ]; then
                echo "Executing - ${command}"
            fi
            delilah ${SAMSON_TEST_HOST}:${SAMSON_WORKER_PORT_ENV} -command "${command}"  >> $TEST_OUTPUT_COMPLETE 2>/dev/null
        done
        grep -v "^[MEWT]:" $TEST_OUTPUT_COMPLETE > $TEST_OUTPUT 2>/dev/null
    fi

    # ------------------------------------------------
    # Execute shell script
    # ------------------------------------------------
    if [ $HAVE_SHELL -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Executing test using bash"
        fi
        if [ $TEST_VERBOSE -eq 1 ]; then
            bash -x $TEST_SHELL_SCRIPT > $TEST_OUTPUT_COMPLETE 2>/dev/null
            grep -v "^[MEWT]:" $TEST_OUTPUT_COMPLETE > $TEST_OUTPUT 2>/dev/null
        else
            bash $TEST_SHELL_SCRIPT > $TEST_OUTPUT_COMPLETE 2>/dev/null
            grep -v "^[MEWT]:" $TEST_OUTPUT_COMPLETE > $TEST_OUTPUT 2>/dev/null
        fi
    fi

    # Check to see if the output is what we expect
    diff -wbB -u $TEST_EXPECT $TEST_OUTPUT > $TEST_DIFF
    if [ $? -ne 0 ]; then
        TEST_FAILED=1
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "----------------------------------------------------------------"
            echo "ERROR: executing $TEST_FILE"
            echo "Expected"
            cat $TEST_EXPECT
            echo "Got"
            cat $TEST_OUTPUT
            if [ $INIT_DELILAH_ERROR -ne 0 ]; then
                echo "Errors were seen initializing delilah"
                echo "STDOUT:"
                cat $TEST_DELILAH_INIT.stdout
                echo "STDERROR:"
                cat $TEST_DELILAH_INIT.stderr
            fi
            if [ $INIT_SHELL_ERROR -ne 0 ]; then
                echo "Errors were seen with the shell initialization script"
                echo "STDOUT:"
                cat $TEST_SHELL_INIT.stdout
                echo "STDERROR:"
                cat $TEST_SHELL_INIT.stderr
            fi
            echo "----------------------------------------------------------------"
        fi
    else
        # Clean up files for succesful test runs
        rm -f $TEST_EXPECT \
                $TEST_OUTPUT \
                $TEST_OUTPUT_COMPLETE \
                $TEST_DELILAH_SCRIPT \
                $TEST_SHELL_SCRIPT \
                $TEST_BASENAME.diff
        if [ ! -z $TEST_DELILAH_INIT ]; then
            rm -f  $TEST_DELILAH_INIT $TEST_DELILAH_INIT.stderr $TEST_DELILAH_INIT.stdout
        fi
        if [ ! -z $TEST_SHELL_INIT ]; then
            rm -f  $TEST_SHELL_INIT $TEST_SHELL_INIT.stderr $TEST_SHELL_INIT.stdout
        fi
    fi

}

function test_header
{
    echo "SAMSON functional unit test harness"
    echo "Machine : $(hostname)"
    echo -n "OS      : "
    if [ -f /etc/lsb-release ]; then
        source /etc/lsb-release 
        echo $DISTRIB_DESCRIPTION
    fi
    echo "Date    : $(date)"
}

function usage
{
    echo "Usage: $0 [test_file|test_directory]"
    exit 1
}

if [ -z $1 ]
then
    usage
else
    test_header
fi

# Set TEST_VERBOSE=1 to show the diffs for failed tests
if [ -z $TEST_VERBOSE ]; then
    TEST_VERBOSE=0
fi

# If we have a directory we'll run a suite of tests
if [ -d $1 ];
then
    TEST_DIR=$1
fi

# Init success and failure counters
TEST_COUNT_SUCCESS=0
TEST_COUNT_FAIL=0

# Execute an individual test
if [ -f $1 ];
then
    TEST_DIR=$(dirname $1)
    TEST_FILE=$(basename $1)
fi

if [ -z "${TEST_DIR}" ]
then
    echo "ERROR: $1 does not exist"
    exit 1
fi

pushd $TEST_DIR > /dev/null
if [ -z ${TEST_FILE} ];
then
    for test in  `find . -name \*.test`
    do
        TEST_FILE=$test
        setup_test_vars
        execute_test
        if [ $TEST_FAILED -eq 1 ]; then
            echo "FAILED : $TEST_NAME ($(basename $TEST_FILE))"
            TEST_COUNT_FAIL=$(expr $TEST_COUNT_FAIL + 1)
            if [ -z "$TEST_FAIL_LIST" ]; then
                TEST_FAIL_LIST=$(echo $TEST_NAME - $(basename $TEST_FILE))
            else
                TEST_FAIL_LIST=$(echo $TEST_FAIL_LIST:$TEST_NAME - $(basename $TEST_FILE))
            fi

        else
            echo "SUCCESS: $TEST_NAME"
            TEST_COUNT_SUCCESS=$(expr $TEST_COUNT_SUCCESS + 1)
        fi

    done
    # Print summary
    echo "===================================================================="
    echo "Test Summary"
    echo "$TEST_COUNT_SUCCESS test(s) passed"
    echo "$TEST_COUNT_FAIL test(s) failed:"
    IFS=":"
    for test in $TEST_FAIL_LIST
    do
        echo $test
    done
    echo "===================================================================="
else
    # Enable verbose output for a single unit-test
    TEST_VERBOSE=1
    setup_test_vars
    execute_test
    if [ $TEST_FAILED -eq 1 ]; then
        echo "FAILED : $TEST_NAME ($(basename $TEST_FILE))"
        TEST_COUNT_FAIL=$(expr $TEST_COUNT_FAIL + 1)
        if [ -z "$TEST_FAIL_LIST" ]; then
            TEST_FAIL_LIST=$(echo $TEST_NAME - $(basename $TEST_FILE))
        else
            TEST_FAIL_LIST=$(echo $TEST_FAIL_LIST:$TEST_NAME - $(basename $TEST_FILE))
        fi

    else
        echo "SUCCESS: $TEST_NAME"
        TEST_COUNT_SUCCESS=$(expr $TEST_COUNT_SUCCESS + 1)
    fi
fi
popd > /dev/null
exit 0
