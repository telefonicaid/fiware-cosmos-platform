
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_system_parse
#define _H_SAMSON_system_parse


#include <samson/module/samson.h>

#include "samson_system/Value.h"
#include "samson_system/Filter.h"

namespace samson{
namespace system{


	class parse : public samson::Parser
	{
        
        samson::system::ValueContainer keyContainer;
        samson::system::ValueContainer valueContainer;
        
        // Collection of filters to execute for every key-value
        FilterCollection filters_collection;
        
        // Internal buffer to store line
        char *line;

	public:


//  INFO_MODULE
// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
// Please, do not remove this comments, as it will be used to check consistency on module declaration
//
//  output: system.Value system.Value
//  
// helpLine: Parse lines with fields separated by a single char tab , space , coma , ...
//  END_INFO_MODULE

		void init( samson::KVWriter *writer )
		{
            // Alloc space for the lines...
            line = (char *) malloc( 20000 );
            
            // By default, value is 1
            valueContainer.value->set_double( 1 );
            
            // Setup the process chain...
            std::string command =  environment->get( "command" ,  "" );
            au::ErrorManager error;
            filters_collection.addFilters( command , writer , NULL , &error );
            
            // Error defined by user
            if (error.IsActivated())
                tracer->setUserError(error.GetMessage());
        }
        
		void run( char *data , size_t length , samson::KVWriter *writer )
		{
            
            size_t offset = 0;
            while( offset < length )
            {
                // Parse a line
                size_t line_pos = 0;
                while( ( offset < length ) && data[offset] != '\n' )
                {
                    if( line_pos < (20000-2) ) // Limit for parsed lines
                        line[line_pos++] = data[offset];
                    offset++;
                }
                offset++; // Skip the '\n'
                line[line_pos] = '\0';
                
                // Set the key with the new string
                keyContainer.value->set_string( line );
                
                
                if( filters_collection.get_num_filters() > 0 )
                {
                    KeyValue kv( keyContainer.value, valueContainer.value );
                    filters_collection.run( kv );
                }
                else
                {                   
                    //Emit the parsed key value
                    writer->emit( 0 , keyContainer.value , valueContainer.value );
                }
            }
		}

		void finish( samson::KVWriter *writer )
		{
            free(line);
		}



	};


} // end of namespace system
} // end of namespace samson

#endif
