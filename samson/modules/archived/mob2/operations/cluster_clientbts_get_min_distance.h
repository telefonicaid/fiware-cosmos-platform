/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_mob2_cluster_clientbts_get_min_distance
#define _H_SAMSON_mob2_cluster_clientbts_get_min_distance


#include <samson/module/samson.h>
#include <samson/modules/mob2/Cluster.h>
#include <samson/modules/mob2/ClusterVector.h>
#include <samson/modules/mob2/Node_Bts.h>
#include <samson/modules/mob2/Poi.h>
#include <samson/modules/mob2/TwoInt.h>
#include <samson/modules/system/UInt.h>
#include "mongo/client/dbclient.h"
#include "mongo/client/dbclientcursor.h"
#include "mob2_environment_parameters.h"



namespace samson{
namespace mob2{


class cluster_clientbts_get_min_distance : public samson::Map
{
	// Inputs
	Node_Bts nodbts;
	ClusterVector clusVector;
	// Outputs
	samson::system::UInt node;
	Poi poi;
	TwoInt node_bts;
	Cluster cluster;

	// Refernce cluster
	ClusterSet clientbtsClusters;

	// MongoDB variables
	std::string          mongo_ip;
	std::string          mongo_db;
	std::string          mongo_collection;
	std::string          mongo_db_path;
	DBClientConnection*  mdbConnection;

	// Environment variable
	int coordsLength;

	// Temporal variables
	samson::system::Double coord;
	Cluster clusterInfo;

public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: mob2.Node_Bts mob2.ClusterVector
	output: system.UInt mob2.Poi
	output: mob2.TwoInt mob2.Cluster

	extendedHelp: 		Calculate the pearson distance between a vector and a cluster

#endif // de INFO_COMMENT

	void init(samson::KVWriter *writer )
	{
		clientbtsClusters.clusterSetLength(0);

		coordsLength = environment->getInt(MOB2_PARAMETER_COORDS_LENGTH, MOB2_PARAMETER_COORDS_LENGTH_DEFAULT);

		mongo_ip           = environment->get("mongo.ip",    "no-mongo-ip");
		mongo_db           = environment->get("mongo.db",    "no-mongo-db");
		mongo_collection   = environment->get("mongo.collection", "no-mongo-collection");

		if (mongo_ip == "no-mongo-ip")
		{
			tracer->setUserError("No mongo ip is specified. Please specify mongo ip with 'mongo.ip' environment variable");
			OLM_E(("No mongo ip specified. Please specify mongo ip with 'mongo.ip' environment variable"));
			return;
		}

		if (mongo_db == "no-mongo-db")
		{
			tracer->setUserError("No db specified. Please specify mongo database db name with 'mongo.db' environment variable");
			OLM_E(("No db specified. Please specify mongo database db name with 'mongo.db' environment variable"));
			return;
		}

		if (mongo_collection == "no-mongo-collection")
		{
			tracer->setUserError("No collection is specified. Please specify mongo collection with 'mongo.collection' environment variable");
			OLM_E(("No collection specified. Please specify mongo database collection name with 'mongo.collection' environment variable"));
			return;
		}

		mongo_db_path = mongo_db + "." + mongo_collection;

		mdbConnection = new DBClientConnection();
		if (mdbConnection == NULL)
		{
			tracer->setUserError("Error creating client mongoDB connection");
			OLM_E(("Error creating client mongoDB connection"));
		}

		try
		{
			mdbConnection->connect(mongo_ip);
		}
		catch ( ... )
		{
			tracer->setUserError("Error connecting to mongo_ip");
			OLM_E(("Error connecting to mongo_ip:'%s'", mongo_ip.c_str()));
		}

		BSONObj                 bo;

		auto_ptr<DBClientCursor> cursor = mdbConnection->query(mongo_db_path);

		int clusId = 0;

		while (cursor->more())
		{
			bo       = cursor->next();
			clusterInfo.label.value = bo.getField("clusterInfo.label").Long();
			//OLM_T(LMT_User06, ("cluster[%d].clusterInfo.label:%lu", clusId, clusterInfo.label.value));
			clusterInfo.labelgroup.value = bo.getField("clusterInfo.labelgroup").Long();
			//OLM_T(LMT_User06, ("cluster[%d].clusterInfo.labelgroup:%lu", clusId, clusterInfo.labelgroup.value));
			clusterInfo.mean.value = bo.getField("clusterInfo.mean").Double();
			//OLM_T(LMT_User06, ("cluster[%d].clusterInfo.mean:%lf", clusId, clusterInfo.mean.value));
			clusterInfo.distance.value = bo.getField("clusterInfo.distance").Double();
			//OLM_T(LMT_User06, ("cluster[%d].clusterInfo.distance:%lf", clusId, clusterInfo.distance.value));
			for(int j=0; j<coordsLength; j++)
			{
#define MAXLENKEY 20
				char coordKey[MAXLENKEY];

				snprintf(coordKey, MAXLENKEY, "coord_%d", j);
				coord.value = bo.getField(coordKey).Double();
				//OLM_T(LMT_User06, ("cluster[%d].%s:%lf", clusId, coordKey, coord.value));
				clusterInfo.coords.comsAdd()->copyFrom(&coord);
			}
			clientbtsClusters.clusterAdd()->copyFrom(&clusterInfo);
			clusId++;
		}

		delete mdbConnection;

	}

	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		// Intermediate
		double dist, mindist;
		double sumcom, sumccom, csumcom, csumccom, sumcomxccom;
		double com, ccom;
		int clusId = -1;

		for(uint64_t i=0; i<inputs[0].num_kvs; i++)
		{
			nodbts.parse(inputs[0].kvs[i]->key);
			clusVector.parse(inputs[0].kvs[i]->value);
			node_bts.num1.value = nodbts.phone.value;
			node_bts.num2.value = nodbts.bts.value;
			cluster.coords.copyFrom(&clusVector);
			mindist = 1000;

			// Calculate min dist - Pearson distance
			for(int nClus=0; nClus<clientbtsClusters.cluster_length; nClus++)
			{
				sumcom = sumccom = csumcom = csumccom = sumcomxccom = 0;
				for(int nComs=0; nComs<clusVector.coms_length; nComs++)
				{
					com = clusVector.coms[nComs].value;
					ccom = clientbtsClusters.cluster[nClus].coords.coms[nComs].value;
					sumcom += com;                          // S1
					sumccom += ccom;                        // S2
					csumcom += com * com;           // SC1
					csumccom += ccom * ccom;        // SC2
					sumcomxccom += com * ccom;      // S12
				}

				int nElem = clusVector.coms_length;
				dist = 1.0 - (((nElem*sumcomxccom)-(sumcom*sumccom))/(sqrt((nElem*csumcom)-(sumcom*sumcom))*sqrt((nElem*csumccom)-(sumccom*sumccom))));

				if(dist < mindist)
				{
					mindist = dist;
					clusId = nClus;
				}
			}
			poi.node.value = node.value = nodbts.phone.value;
			poi.bts.value = nodbts.bts.value;

			//FILTER BY DISTANCE
			cluster.label.value = clientbtsClusters.cluster[clusId].label.value;
			cluster.labelgroup.value = clientbtsClusters.cluster[clusId].labelgroup.value;
			poi.labelnodebts.value = clientbtsClusters.cluster[clusId].label.value;
			poi.labelgroupnodebts.value = clientbtsClusters.cluster[clusId].labelgroup.value;

			if(mindist > clientbtsClusters.cluster[clusId].distance.value)
			{
				cluster.confident.value = 0;
				poi.confidentnodebts.value = 0;
			}
			else
			{
				cluster.confident.value = 1;
				poi.confidentnodebts.value = 1;
			}
			cluster.mean.value = 0;
			poi.distancenodebts.value = cluster.distance.value = mindist;
			poi.labelnode.value = poi.labelgroupnode.value = poi.distancenode.value = 0;
			poi.labelbts.value = poi.labelgroupbts.value = poi.distancebts.value = 0;
			writer->emit(0, &node,&poi);
			writer->emit(1, &node_bts,&cluster);
		}

	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace mob2
} // end of namespace samson

#endif
