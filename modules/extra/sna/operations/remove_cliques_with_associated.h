
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_sna_remove_cliques_with_associated
#define _H_SAMSON_sna_remove_cliques_with_associated


#include <samson/module/samson.h>



namespace samson{
namespace sna{


class remove_cliques_with_associated : public samson::Reduce
{
	Clique clique ;
	samson::system::Void void_data ;

public:


	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		// we tolerate multiple entries at the input
		if( inputs[0].num_kvs < 0)
		{
			OLM_E(("Error, inputs[0].num_kvs(%d) < 0", inputs[0].num_kvs));
		}


		//Only emit if we do not have anything at the second input
		if( inputs[1].num_kvs == 0)
		{
			Clique clique_value_tmp;
			Clique clique_associated;
			std::map<uint,short> associated;

			clique.parse ( inputs[0].kvs[0]->key );
			for (int i = 0 ; i < clique.nodes_length ; i++ ){
				associated[ clique.nodes[i].value ] = 0;
			}

			for (size_t i = 0  ; i < inputs[0].num_kvs ; i++)
			{
				clique_value_tmp.parse ( inputs[0].kvs[0]->value );

				for (int j = 0  ; j < clique_value_tmp.nodes_length ; j++)
					associated[ clique_value_tmp.nodes[j].value ]++;
			}


			for (int i = 0 ; i < clique.nodes_length ; i++ )
			{
				//BUG Solved by Alberto
				if ( associated[ clique.nodes[i].value ] != inputs[1].num_kvs )
				{
					clique_associated.nodesAdd()->value = clique.nodes[i].value;
				}
			}

			writer->emit(0, &clique, &clique_associated);
		}
	}


};


} // end of namespace samson
} // end of namespace sna

#endif
