/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_c4_process
#define _H_SAMSON_c4_process
#include "logMsg/logMsg.h"

#include <samson/module/samson.h>
#include <samson/modules/c4/Board.h>
#include <samson/modules/c4/Info.h>
#include <samson/modules/c4/Message.h>

namespace samson {
namespace c4 {

class process : public samson::Reduce {

    samson::c4::Board board;   // SAMSON Board data
    samson::c4::Info info;   // Information about this board

    au::c4::Board current_board;   // Analysis of the current board
    au::c4::Board next_boards[7];   // Vector of possible movements
    size_t next_boards_size;
  public:

    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: c4.Board c4.Message
    //  input: c4.Board c4.Info
    //  output: c4.Board c4.Message
    //  output: c4.Board c4.Info
    //
    //  END_INFO_MODULE

    void init(samson::KVWriter *writer) {
    }

    void run(samson::KVSetStruct* inputs, samson::KVWriter *writer) {
      //printf("Processing key-values %lu %lu\n" , inputs[0].num_kvs , inputs[1].num_kvs );

      // ------------------------------------------------------------------
      // Get Board
      // ------------------------------------------------------------------

      if (inputs[1].num_kvs > 0)
        board.parse(inputs[1].kvs[0]->key);
      else
        board.parse(inputs[0].kvs[0]->key);

      // Internal structure to analyse better current board
      current_board.SetBoard(board.white.value, board.black.value);

      // Get future boards with all movements
      next_boards_size = current_board.GetNextBoards(board.turn.value, next_boards);

      // ------------------------------------------------------------------
      // Get previous info or analyse board
      // ------------------------------------------------------------------

      if (inputs[1].num_kvs > 0) {
        info.parse(inputs[1].kvs[0]->value);   // There is a previous board here
      } else {
        // New info structure
        info.reset();

        // Check for direct winners
        for (size_t i = 0; i < next_boards_size; i++)
          info.movement[i].value = next_boards[i].GetWinner();

        // Compute final result based on particals
        review();

        // If the result is unknown, I sent forward message to new boards
        if (info.winner.value == C4_NONE) {
          for (size_t i = 0; i < next_boards_size; i++) {
            samson::c4::Board forward_board;
            forward_board.white.value = next_boards[i].white_value();
            forward_board.black.value = next_boards[i].black_value();
            forward_board.turn.value = -board.turn.value;   // It is the other turn

            samson::c4::Message message;
            message.type.value = 1;   // Forward message
            message.board.copyFrom(&board);

            writer->emit(0, &forward_board, &message);

          }
        }

      }

      // Process messages
      samson::c4::Message message;
      for (size_t i = 0; i < inputs[0].num_kvs; i++) {
        message.parse(inputs[0].kvs[i]->value);

        if (message.type.value == 1) {
          // Forward message: another board is requesting our solution
          // add to the vector of boards to be answered
          samson::c4::Board* tmp_board = info.boardsAdd();
          tmp_board->copyFrom(&message.board);
        } else if (message.type.value == 2) {
          // Response message: another board is answering our demand of solution
          for (int i = 0; i < (int) next_boards_size; i++) {
            if (next_boards[i].white_value() != message.board.white.value)
              continue;
            if (next_boards[i].black_value() != message.board.black.value)
              continue;

            // Set the solution
            info.movement[i] = message.winner;
            break;
          }
        }
      }

      // Review board ( based on new information, if any... )
      review();

      // If board is revolved, send message back to pending boards and remove them
      if (info.winner.value != C4_NONE) {
        for (int i = 0; i < info.boards_length; i++) {
          samson::c4::Message message;
          message.type.value = 2;   // Response message
          message.winner.value = info.winner.value;   // Winner of this board
          message.board.copyFrom(&board);   // this board

          writer->emit(0, &info.boards[i], &message);
        }
        info.boardsSetLength(0);   // Remove vector of pending boards
      }

      // Emit current state (always) at the output
      writer->emit(1, &board, &info);

    }

    void review() {
      // If one movement is winner, I win
      for (size_t i = 0; i < next_boards_size; i++)
        if (info.movement[i].value == board.turn.value) {
          info.winner.value = board.turn.value;   // me
          return;
        }

      // If Any is unknown, still unknown ( there is hope... )
      for (size_t i = 0; i < next_boards_size; i++)
        if (info.movement[i].value == C4_NONE) {
          info.winner.value = C4_NONE;
          return;
        }

      // If any is DRAW, it is DRAW ( best possibiliy for us now... )
      for (size_t i = 0; i < next_boards_size; i++)
        if (info.movement[i].value == C4_DRAW) {
          info.winner.value = C4_DRAW;
          return;
        }

      // I have no option, so I lost
      info.winner.value = -board.turn.value;
    }

    void finish(samson::KVWriter *writer) {
    }

};

} // end of namespace c4
} // end of namespace samson

#endif
