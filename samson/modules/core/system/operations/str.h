/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_system_str
#define _H_SAMSON_system_str

#include <samson/module/samson.h>
#include <samson_system/Value.h>
#include "samson_system/Filter.h"

namespace samson {
namespace system {

class str : public samson::ParserOut {

    samson::system::ValueContainer keyContainer;
    samson::system::ValueContainer valueContainer;

    // Collection of filters to execute for every key-value
    FilterCollection filters_collection;

  public:

    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: system.Value system.Value
    //
    // helpLine: Export system.Value system.Value elements to string
    //  END_INFO_MODULE

    void init(TXTWriter *writer) {
      // Setup the process chain...
      std::string command = environment->get("command", "");

      if (command == "") {
        tracer->setUserError("Environment variable command not specified. Please specify with env:command XXX");
        return;
      }

      au::ErrorManager error;
      filters_collection.AddFilters(command, NULL, writer, &error);

      // Error defined by user
      if (error.IsActivated())
        tracer->setUserError(error.GetMessage());
    }

    void run(KVSetStruct* inputs, TXTWriter *writer) {
      for (size_t i = 0; i < inputs[0].num_kvs; i++) {
        keyContainer.value->parse(inputs[0].kvs[i]->key);
        valueContainer.value->parse(inputs[0].kvs[i]->value);

        KeyValue kv(keyContainer.value, valueContainer.value);
        filters_collection.run(kv);
      }
    }

    void finish(TXTWriter *writer) {
    }

};

} // end of namespace system
} // end of namespace samson

#endif
