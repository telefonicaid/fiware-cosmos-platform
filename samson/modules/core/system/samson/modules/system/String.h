/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 * File autogenerated with samsonModuleParser. Please, edit to complete this data
 */

#ifndef _H_SAMSON_system_String
#define _H_SAMSON_system_String

#include <iostream>
#include <sstream>

#ifdef DEBUG_FILES
#include <fstream>
#endif  /* de DEBUG_FILES */




namespace samson {
namespace system {
class String : public samson::DataInstance {
public:

  std::string value;

  String() : samson::DataInstance() {
  }

  ~String() {
  }

  std::string getName() {
    return "system.String";
  }

  int parse(char *data) {
    int pos = 0;

    while (data[pos] != '\0') {
      pos++;
    }
    value = data;
    return pos + 1;
  }

  int serialize(char *data) {
    int l = value.length();

    memcpy(data, value.c_str(), l);
    data[l] = '\0';
    return l + 1;
  }

  int hash(int max_num_partitions) {
    static const size_t InitialFNV = 2166136261U;
    static const size_t FNVMultiple = 16777619;

    size_t hash = InitialFNV;

    for (size_t i = 0; i < value.length(); i++) {
      hash = hash ^ (value[i]);             /* xor  the low 8 bits */
      hash = hash * FNVMultiple;            /* multiply by the magic number */
    }
    return hash % max_num_partitions;
  }

  static int size(char *data) {
    int pos = 0;

    while (data[pos] != '\0') {
      pos++;
    }
    return pos + 1;
  }

  inline static int compare(char *data1, char *data2, size_t *offset1, size_t *offset2) {
    char *data1_orig = data1 + *offset1;
    char *data2_orig = data2 + *offset2;
    int pos1 = 0;

#ifdef DEBUG_FILES
    {
      std::string filename = "/tmp/String_compare.log";
      std::ofstream fs(filename.c_str(), std::ios::app);
      fs << "Compare: (" << data1_orig << ", " << data2_orig << ") offset1: " << *offset1 << ", offset2: " <<
      *offset2 << std::endl;
      fs.close();
    }
#endif  /* de DEBUG_FILES */
#undef DEBUG_FILES

    while (data1_orig[pos1] != '\0') {
      pos1++;
    }

    int pos2 = 0;
    while (data2_orig[pos2] != '\0') {
      pos2++;
    }

    *offset1 += pos1 + 1;
    *offset2 += pos2 + 1;

#ifdef DEBUG_FILES
    {
      std::string filename = "/tmp/String_compare.log";
      std::ofstream fs(filename.c_str(), std::ios::app);
      fs << "update offset1: " << *offset1 << ", offset2: " << *offset2 << std::endl;
      fs.close();
    }
#endif  /* de DEBUG_FILES */
#undef DEBUG_FILES
    // if( pos1 < pos2 )
    //   return -1;
    // else if( pos1 > pos2 )
    //   return 1;

    // Same length

    // By extending comparison to the last character ('\0'), we don't have to check lengths
    for (int i = 0; i <= pos1; i++) {
      if (data1_orig[i] < data2_orig[i]) {
        return -1;
      } else if (data1_orig[i] > data2_orig[i]) {
        return 1;
      }
    }

    // Same content
    return 0;
  }

  inline static int compare(char *data1, char *data2) {
    size_t offset_1 = 0;
    size_t offset_2 = 0;

    return compare(data1, data2, &offset_1, &offset_2);
  }

  int serial_compare(char *data1, char *data2) {
    return compare(data1, data2);
  }

  int *getDataPath(const std::string &dataPathString) {
    return(getDataPathStatic(dataPathString));
  }

  static int *getDataPathStatic(const std::string &dataPathString) {
    const char *dataPathCharP = dataPathString.c_str();
    int nlevels = 1;
    int *dataPathIntP;

    const char *p_sep = dataPathCharP;

    while ((p_sep = strchr(p_sep, '.')) != NULL) {
      nlevels++;
      p_sep++;
    }

    if ((dataPathIntP = (int *)malloc((nlevels + 1) * sizeof(int))) == NULL) {
      return ((int *)NULL);
    }

    int retError = getDataPath(dataPathCharP, dataPathIntP);

    if (retError) {
      free(dataPathIntP);
      dataPathIntP = NULL;
    }

    return  (dataPathIntP);
  }

  void setFromString(const char *_data) {
    char *p_data_decoded = NULL;
    bool inputStringDecoded = false;

    if (strstr(_data, "%20") != NULL) {
      inputStringDecoded = true;

      p_data_decoded = strdup(_data);
      char *p_next_data = p_data_decoded;
      char *p_blank;


      while ((p_blank = strstr(p_next_data, "%20")) != NULL) {
        *p_blank++ = ' ';
        strcpy(p_blank, p_blank + strlen("%02") - 1);
        p_next_data = p_blank;
      }
    } else {
      p_data_decoded = (char *)_data;
    }

    char *p_item;
    int length;

    p_item = p_data_decoded;

    if (*p_item == '\"') {
      p_item++;
      char *p_next_item = p_item;
      char *p_end;
      length = strlen(p_item);
      while ((p_end = strchr(p_next_item, '\"')) != NULL) {
        if (*(p_end - 1) != '\\') {
          length = p_end - p_item;
          break;
        }
        p_next_item = p_end + 1;
      }
    } else {
      p_item = (char *)_data;
      length = strlen(p_item);
    }
    value = std::string(p_item, length);
    if (inputStringDecoded) {
      free(p_data_decoded);
    }
  }

  static int getDataPath(const char *dataPathCharP, int *dataPathIntP) {
    if (*dataPathCharP == 0) {
      *dataPathIntP = -1;
      return (0);
    }

    if (strcmp(dataPathCharP, "String") == 0) {
      *dataPathIntP = -1;
      return (0);
    }

    return -1;
  }

  std::string getTypeFromPath(const std::string &dataPathString) {
    const char *dataPathCharP = dataPathString.c_str();

    return(getTypeFromPathStatic(dataPathCharP));
  }

  static std::string getTypeFromPathStatic(const char *dataPathCharP) {
    if (*dataPathCharP == 0) {
      return ("system.String");
    }
    if (strcmp(dataPathCharP, ".") == 0) {
      return ("system.String");
    }

    if (strcmp(dataPathCharP, "String") == 0) {
      return ("system.String");
    }
    return("_ERROR_");
  }

  std::string getTypeFromPath(const int *dataPathIntP) {
    return(getTypeFromPathStatic(dataPathIntP));
  }

  static std::string getTypeFromPathStatic(const int *dataPathIntP) {
    switch (*dataPathIntP) {
      case -1:
        return ("system.String");

        break;
      default:
        return ("_ERROR_");

        break;
        break;
    }
    ;
    return "_ERROR_";
  }

  static const char *getTypeStatic() {
    return ("system.String");
  }

  const char *getType() {
    return ("system.String");
  }

  static bool checkTypeStatic(const char *type) {
    if (strcmp(type, "system.String") == 0) {
      return true;
    }
    return false;
  }

  bool checkType(const char *type) {
    if (strcmp(type, "system.String") == 0) {
      return true;
    }
    return false;
  }

  static size_t getHashTypeStatic() {
    return(6957788883659133127ULL);
  }

  size_t getHashType() {
    return(6957788883659133127ULL);
  }

  static bool checkHashTypeStatic(size_t valType) {
    if (valType == 6957788883659133127ULL) {
      return true;
    }
    return false;
  }

  bool checkHashType(size_t valType) {
    if (valType == 6957788883659133127ULL) {
      return true;
    }
    return false;
  }

  DataInstance *getDataInstanceFromPath(const int *dataPathIntP) {
    switch (*dataPathIntP) {
      case -1:
        return (this);

        break;
      default:
        return (NULL);

        break;
    }
    ;
    return NULL;
  }

  void copyFrom(String *other) {
    value = other->value;
  };

  std::string str() {
    return ("\"" + value + "\"");
  }

  std::string strJSON() {
    std::ostringstream o;
    String strEscaped;

    strEscaped.value = value;;
    strEscaped.findAndReplace("\\", "\\\\");
    strEscaped.findAndReplace("\"", "\\\"");
    // strEscaped.findAndReplace("\/", "\\/");
    strEscaped.findAndReplace("\b", "\\b");
    strEscaped.findAndReplace("\f", "\\f");
    strEscaped.findAndReplace("\n", "\\n");
    strEscaped.findAndReplace("\r", "\\r");
    strEscaped.findAndReplace("\t", "\\t");
    o << "\""  << strEscaped.value << "\"";
    return o.str();
  }

  std::string strXML() {
    std::ostringstream o;

    o << "<![CDATA[" << value << "]]>";
    return o.str();
  }

  std::string strHTML(int level_html_heading) {
//        std::ostringstream o;
//        o   << str();
    // o << "<h" <<  level_html_heading << ">" << value << "</h" << level_html_heading << ">";
    return str();
  }

  std::string strHTMLTable(std::string _varNameInternal) {
    std::ostringstream o;

    o <<
    "<style>#table-5{font-family:\"Lucida Sans Unicode\", \"Lucida Grande\", Sans-Serif;font-size:12px;background:#fff;border-collapse:collapse;text-align:left;margin:20px;}#table-5 th{text-align:center;font-size:14px;font-weight:normal;color:#039;border-bottom:2px solid #6678b1;padding:10px 8px;}#table-5 td{color:#669;padding:9px 8px 0;}#table-5 tbody tr:hover td{color:#009;}</style>";
    o << "<table id=\"table-5\">\n";
    o << "<caption>" <<  _varNameInternal << "</caption>\n";
    o << "<tr>\n";
    o << "<th>" << _varNameInternal << "</th>\n";
    o << "</tr>\n";
    o << "<tr>\n";
    o << "<th>" << getName() << "</th>\n";
    o << "</tr>\n";
    o << "<td>" << str() << "</td>\n";
    o << "</tr>\n";
    o << "</table>\n";
    return o.str();
  }

  std::string paint_header(int init_col) {
    return "Term";
  }

  std::string paint_header_basic(int init_col) {
    return "Term";
  }

  std::string paint_value(int index_row) {
    std::ostringstream o;

    if (index_row >= 0) {
      o << "<td>" << str() << "</td>";
    } else {
      o << "<td></td>";
    }
    return o.str();
  }

  int num_fields() {
    return 1;
  }

  int num_basic_fields() {
    return 1;
  }

  int max_depth() {
    return 1;
  }

  int max_num_values() {
    return 1;
  }

  bool is_terminal() {
    return true;
  }

  void operator=(std::string &_value) {
    value = _value;
  }

  void convertToLowerCase() {
    for (size_t i = 0; i < value.length(); i++) {
      char c = (char)value[i];

      if ((c >= 65) && (c <= 90)) {
        value[i] = c + 32;
      }
    }
  }

  bool isStandartWord() {
    for (size_t i = 0; i < value.length(); i++) {
      char c = (char)value[i];

      if ((c >= 97) && (c <= 122)) {
        // Lower case letter
        continue;
      }

      if ((c >= 65) && (c <= 90)) {
        // Lower case letter
        continue;
      }

      return false;
    }

    return true;
  }

  bool isMail() {
    bool arroba_found = false;
    bool point_found_in_domain = false;

    for (size_t i = 0; i < value.length(); i++) {
      char c = (char)value[i];

      if (c == 64) {
        if (i == 0) {
          return false;           // Not starting with "@"
        }
        if (arroba_found) {
          return false;
        } else {
          arroba_found = true;
        }
        continue;
      }

      if ((c >= 97) && (c <= 122)) {
        // Lower case letter
        continue;
      }

      if (c == '.') {
        if (arroba_found) {
          point_found_in_domain = true;
        }
        continue;
      }
      if (c == '-') {
        continue;
      }
      if (c == '_') {
        continue;
      }

      return false;
    }

    if (arroba_found && point_found_in_domain) {
      return true;
    }

    return false;
  }

  void set(const char *str) {
    value = str;
  }

  void findAndReplace(std::string strToFind, std::string strToReplace) {
    // handle error situations/trivial cases

    if (strToFind.length() == 0) {
      // searching for a match to the empty string will result in
      //  an infinite loop
      //  it might make sense to throw an exception for this case
      return;
    }

    if (value.length() == 0) {
      return;        // nothing to match against
    }

    size_t idx = 0;

    for (;; ) {
      idx = value.find(strToFind, idx);
      if (idx == std::string::npos) {
        break;
      }

      value.replace(idx, strToFind.length(), strToReplace);
      idx += strToReplace.length();
    }
  }
};
}  // end of namespace samson
}  // end of namespace system

#endif  // ifndef _H_SAMSON_system_String
