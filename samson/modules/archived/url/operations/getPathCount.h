/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_url_getPathCount
#define _H_SAMSON_url_getPathCount

#include <algorithm>
#include <samson/module/samson.h>





namespace samson{
namespace url{


	class getPathCount : public samson::Reduce
	{

	public:

		samson::system::UInt serverId;
		samson::system::String pathStr;

		PathCount pathCount;
		std::vector <PathCount> pathStdVector;


		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{



			bool first = true;
			samson::system::String pathStrPrev;
			int count = 0;

			size_t num_hits = environment->getSizeT("url.num_hits", 3);

			serverId.parse(inputs[0].kvs[0]->key);
			pathStdVector.clear();

			for (size_t i = 0; (i < inputs[0].num_kvs); i++)
			{
				pathStr.parse(inputs[0].kvs[i]->value);
				//OLM_T(LMT_User06,("For serverId:%d  path:%s", serverId.value, pathStr.value.c_str()));
				if (first || (!pathStr.value.compare(pathStrPrev.value)))
				{
					count++;
					//OLM_T(LMT_User06,("\t(%d) Increment count to %d", serverId.value, count));
					first = false;
				}
				else
				{
					//OLM_T(LMT_User06,("(%d) It's a new path, store %s with count:%d", serverId.value, pathStrPrev.value.c_str(), count));
					pathCount.path = pathStrPrev;
					pathCount.count = count;
					pathStdVector.push_back(pathCount);
					count = 1;
				}
				pathStrPrev = pathStr;
			}
			//OLM_T(LMT_User06,("(%d) It's the last path, store %s with count:%d", serverId.value, pathStrPrev.value.c_str(), count));
			pathCount.path = pathStrPrev;
			pathCount.count = count;
			pathStdVector.push_back(pathCount);

			// Would be cleaner to left the sort by count and the truncate to a next reduce,
			// but it is simpler to make it here.

			std::sort ( pathStdVector.begin() , pathStdVector.end(), PathCount::compare_by_count );

			PathCountVector paths;

			size_t countRef = 0;
			size_t count_hits = 0;
			for ( std::vector<PathCount>::iterator iter = pathStdVector.begin() ; ((iter < pathStdVector.end()) && (count_hits < num_hits)) ; iter++, count_hits++)
			{
				pathCount = *iter;
				paths.pathsCountAdd()->copyFrom(&pathCount);
				//OLM_T(LMT_User06,("(%d) Adds path:%s, count:%d", serverId.value, pathCount.path.value.c_str(), pathCount.count.value));
				countRef += iter->count.value;
			}
			paths.countRef = countRef;
			writer->emit(0, &serverId, &paths);
		}


	};


} // end of namespace samson
} // end of namespace url

#endif
