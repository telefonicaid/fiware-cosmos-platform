/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_snalight_parse_cdrs
#define _H_SAMSON_snalight_parse_cdrs


#include <samson/module/samson.h>

#include "sna_parsing_macros.h"
#include "sna_environment_parameters.h"
#include <assert.h>

namespace samson{
namespace snalight{



void get_cdrs_next_field0(char *line, int *pos, int *pos_field)
{
	assert (line != NULL);
	*pos_field = *pos;
	while ((line[*pos] != '|') && (line[*pos] != '\0' ))
		{
		(*pos)++;
		}
	line[*pos] = '\0';
	(*pos)++;

		assert((*pos - *pos_field) < 100);
}

void get_cdrs_next_field1(char *line, int *pos, int *pos_field)
{
	assert (line != NULL);
	*pos_field = *pos;
	while ((line[*pos] != '|') && (line[*pos] != '\0' ))
		{
		(*pos)++;
		}
	line[*pos] = '\0';
	(*pos)++;
	assert((*pos - *pos_field) < 100);
}

void get_cdrs_next_field2(char *line, int *pos, int *pos_field)
{
	assert (line != NULL);
	*pos_field = *pos;
	while ((line[*pos] != '|') && (line[*pos] != '\0' ))
		{
		(*pos)++;
		}
	line[*pos] = '\0';
	(*pos)++;
	assert((*pos - *pos_field) < 100);
}

void get_cdrs_next_field3(char *line, int *pos, int *pos_field)
{
	assert (line != NULL);
	*pos_field = *pos;
	while ((line[*pos] != '|') && (line[*pos] != '\0' ))
		{
		(*pos)++;
		}
	line[*pos] = '\0';
	(*pos)++;
	assert((*pos - *pos_field) < 100);
}

size_t get_cdrs_get_number(char *line, int *pos, int *pos_field)
{
	return (atoll(line +*pos_field));
}


class parse_cdrs : public samson::Parser
{

	//typedef bool (getCDRFunction)( char*line, samson::system::UInt *node, CDR* info);
	//getCDRFunction *_getCDRFunction ;

	bool (parse_cdrs ::*_getCDRFunction)( char*line, samson::system::UInt *node, CDR* info);

public:

	bool getCDRFromLine_TME( char *line, samson::system::UInt*node, CDR* cdr )
	{
		//LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
		//Note: multihtread save implementation



		GET_CDRS_INIT_NO_MX

		GET_CDRS_NEXT_FIELD
		//First field useless

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_NUMBER( node->value )

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_NUMBER( cdr->node.value )


		GET_CDRS_NEXT_FIELD

/*
		cdr->date.day   = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year    = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );

		cdr->time.hour    = CHAR_TO_INT( line[pos_field+9] ) *10 + CHAR_TO_INT( line[pos_field+10] );
		cdr->time.minute  = CHAR_TO_INT( line[pos_field+12] ) *10 + CHAR_TO_INT( line[pos_field+13] );
		cdr->time.seconds = CHAR_TO_INT( line[pos_field+15] ) *10 + CHAR_TO_INT( line[pos_field+16] );
*/


		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_DURATION(cdr->duration.value)


		//Global Checking...
		if(cdr->node.value <= 0)        return false;
		if(node->value <= 0)      return false;
		if(node->value == cdr->node.value)  return false;

		return true;
	}


	bool getCDRFromLine_TEMM_VOZ( char *line, samson::system::UInt*node, CDR* cdr )
	{
		//HEADER --> "CELL_START|PHONE1|CELL_FINISH|PHONE2|DIR|DATE|TIME|DURATION"
		//LINE   --> "33F43052167D16|2221435146|33F43052167D16|0442221472843|2|04/01/2010|17:21:07|22"
		//Note: multihtread save implementation


		//OLM_T(LMT_User01, ("Enters:getCDRFromLine_TEMM_VOZ()"));
		//char *dupLine = strdup(line);

		GET_CDRS_INIT
		//OLM_T(LMT_User01, ("Passed GET_CDRS_INIT"));


		GET_CDRS_NEXT_FIELD
		//Unused field -- START CELL
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for START CELL"));

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for PHONE"));
		GET_CDRS_GET_PHONE_MX( node->value )
		//OLM_T(LMT_User01, ("Passed GET_CDRS_GET_PHONE_MX"));



		GET_CDRS_NEXT_FIELD
		//Unused field -- FINISH CELL
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for FINISH CELL"));

		GET_CDRS_NEXT_FIELD
		//pos_field+=3; // Skip 3 characters of this number
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for PHONE"));
		GET_CDRS_GET_PHONE_MX( cdr->node.value )
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for PHONE"));
/*		if (cdr->node.value < 10000)
		{
			OLM_T(LMT_User06, ("User %lu detected in '%s'(%s) at pos:%d, pos_field:%d, pos_celd:%d, length_celd:%d", cdr->node.value, line+pos_celd, dupLine, pos, pos_field, pos_celd, length_celd));
		}
		free(dupLine);*/

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DIR"));
		GET_CDRS_GET_DIR( cdr->dir.value )
		//OLM_T(LMT_User01, ("Passed GET_CDRS_GET_DIR for PHONE"));

		if(cdr->dir.value == 2){
			cdr->dir.value = 0;
		}

		//GET_CDRS_NEXT_FIELD
		//Unused field -- CALL TYPE

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DATE"));

/*
		cdr->date.day     = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year    = CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );
*/

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for TIME"));

/*
		cdr->time.hour    = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->time.minute  = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->time.seconds = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );
*/

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DURATION"));
		GET_CDRS_GET_DURATION(cdr->duration.value)

		cdr->type.value = 0;

		//Global Checking...
		//Global Checking...
		if(cdr->node.value <= 999999999)
		{
			//OLM_E(("Error in CDR for cdr->node(%ld) < 999999999", cdr->node.value));
			return false;
		}
		if(node->value <= 999999999)
		{
			//OLM_E(("Error in CDR for node(%ld) < 999999999", node->value));
			return false;
		}
		if(node->value == cdr->node.value)
		{
			//OLM_E(("Error in CDR for (node->value == cdr->node.value)", node->value, cdr->node.value));
			return false;
		}
		if((cdr->dir != 1) && (cdr->dir != 0))
		{
			//OLM_E(("Error in CDR for ((cdr->dir(%ld) != 1) && (cdr->dir != 0))", cdr->dir.value));
			return false;
		}

		return true;
	}

	bool getCDRFromLine_TEMM_VOZ_15fields( char *line, samson::system::UInt*node, CDR* cdr )
	{
		//HEADER --> "CELL_START|PHONE1|CELL_FINISH|PHONE2|DIR|DATE|TIME|DURATION"
		//LINE   --> "33F43052167D16|2221435146|33F43052167D16|0442221472843|2|04/01/2010|17:21:07|22"

		//In 100_CDRS we have GASSET_TRAFICO_VOZ_20090228.DAT
		//HEADER --> "CELL_START|PHONE1|CELL_FINISH|PHONE2|DIR|TYPE|DATE|TIME|DURATION|CIA_1|CIA_2|UNK_1|UNK_2|OTHER|FACT"
		//LINE   --> "33F43061B65B61|6671573918||018188803536|2|LDN|28/02/2009|03:09:54|3600|118-MOVISTAR|102-BESTPHONE|||354825013513420|RMNACIO"



		//OLM_T(LMT_User01, ("Enters:getCDRFromLine_TEMM_VOZ()"));

		//char *dupLine = strdup(line);

		node->value = 0;
		cdr->node.value = 0;

		GET_CDRS_INIT
		//OLM_T(LMT_User01, ("Passed GET_CDRS_INIT"));


		GET_CDRS_NEXT_FIELD
		//Unused field -- START CELL
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for START CELL"));

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for PHONE"));
		GET_CDRS_GET_PHONE_MX( node->value )
		//OLM_T(LMT_User01, ("Passed GET_CDRS_GET_PHONE_MX, field:%s, node->value:%ld", line+pos_field, node->value));





		GET_CDRS_NEXT_FIELD
		//Unused field -- FINISH CELL
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for FINISH CELL"));

		GET_CDRS_NEXT_FIELD
		//pos_field+=3; // Skip 3 characters of this number
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for PHONE"));
		GET_CDRS_GET_PHONE_MX( cdr->node.value )
		//OLM_T(LMT_User01, ("Passed GET_CDRS_GET_PHONE_MX, field:%s, cdr->node:%ld", line+pos_field, cdr->node.value));
		//if (cdr->node.value < 10000)
		//{
			//OLM_T(LMT_User06, ("User %lu detected in '%s'(%s) at pos:%d, pos_field:%d, pos_celd:%d, length_celd:%d", cdr->node.value, line+pos_celd, dupLine, pos, pos_field, pos_celd, length_celd));
		//}
		//free(dupLine);

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DIR"));
		GET_CDRS_GET_DIR( cdr->dir.value )
		//OLM_T(LMT_User01, ("Passed GET_CDRS_GET_DIR for PHONE"));

		if(cdr->dir.value == 2){
			cdr->dir.value = 0;
		}

		GET_CDRS_NEXT_FIELD
		//Unused field -- CALL TYPE

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DATE"));

/*
		cdr->date.day.value     = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month.value   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year    = CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );
*/

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for TIME"));

/*
		cdr->time.hour.value    = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->time.minute.value  = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->time.seconds.value = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );
*/

		GET_CDRS_NEXT_FIELD
		//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DURATION"));
		GET_CDRS_GET_DURATION(cdr->duration.value)

		cdr->type.value = 0;

		//Global Checking...
		if(cdr->node.value <= 999999999)
		{
			//OLM_E(("Error in CDR for cdr->node(%ld) < 999999999", cdr->node.value));
			return false;
		}
		if(node->value <= 999999999)
		{
			//OLM_E(("Error in CDR for node(%ld) < 999999999", node->value));
			return false;
		}
		if(node->value == cdr->node.value)
		{
			//OLM_E(("Error in CDR for (node->value == cdr->node.value)", node->value, cdr->node.value));
			return false;
		}
		if((cdr->dir.value != 1) && (cdr->dir.value != 0))
		{
			//OLM_E(("Error in CDR for ((cdr->dir(%d) != 1) && (cdr->dir != 0))", cdr->dir.value));
			return false;
		}

		return true;
	}


	bool getCDRFromLine_TEMM_SMS( char *line, samson::system::UInt*node, CDR* cdr )
	{
		//HEADER --> "PHONE1|PHONE2|DIR|Date|Time"
		//LINE --> "6862360363|9371302781|2|01/08/2009|17:52:05"
		//Note: multihtread save implementation

		GET_CDRS_INIT

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_PHONE_MX( node->value )

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_PHONE_MX( cdr->node.value )

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_DIR( cdr->dir.value )

		if(cdr->dir.value == 2){
			cdr->dir.value = 0;
		}

		GET_CDRS_NEXT_FIELD

/*
		cdr->date.day     = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year    = CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );
*/

		GET_CDRS_NEXT_FIELD

/*
		cdr->time.hour    = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->time.minute  = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->time.seconds = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );
*/

		cdr->duration.value = 0;
		cdr->type.value = 1;

		//Global Checking...(10 digits)
		//Global Checking...
		if(cdr->node.value <= 999999999)
		{
			OLM_E(("Error in CDR for cdr->node(%ld) < 999999999", cdr->node.value));
			return false;
		}
		if(node->value <= 999999999)
		{
			OLM_E(("Error in CDR for node(%ld) < 999999999", node->value));
			return false;
		}
		if(node->value == cdr->node.value)
		{
			OLM_E(("Error in CDR for (node->value == cdr->node.value)", node->value, cdr->node.value));
			return false;
		}
		if((cdr->dir.value != 1) && (cdr->dir.value != 0))
		{
			OLM_E(("Error in CDR for ((cdr->dir(%ld) != 1) && (cdr->dir != 0))", cdr->dir.value));
			return false;
		}


		return true;
	}

	bool getCDRFromLine_TEMM_MMS( char *line, samson::system::UInt*node, CDR* cdr )
	{
		//HEADER --> "PHONE1|PHONE2|DIR|Date|Time"
		//LINE   --> "525523749235|5541871842|1|01/08/2009|00:30:02"
		//Note: multihtread save implementation

		GET_CDRS_INIT

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_PHONE_MX( node->value )

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_PHONE_MX( cdr->node.value )

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_DIR( cdr->dir.value )

		if(cdr->dir.value == 2){
			cdr->dir.value = 0;
		}

		GET_CDRS_NEXT_FIELD

/*
		cdr->date.day     = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year    = CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );
*/

		GET_CDRS_NEXT_FIELD

/*
		cdr->time.hour    = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->time.minute  = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->time.seconds = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );
*/

		cdr->duration = 0;
		cdr->type = 2;

		//Global Checking...
		//Global Checking...
		if(cdr->node.value <= 999999999)
		{
			OLM_E(("Error in CDR for cdr->node(%ld) < 999999999", cdr->node.value));
			return false;
		}
		if(node->value <= 999999999)
		{
			OLM_E(("Error in CDR for node(%ld) < 999999999", node->value));
			return false;
		}
		if(node->value == cdr->node.value)
		{
			OLM_E(("Error in CDR for (node->value == cdr->node.value)", node->value, cdr->node.value));
			return false;
		}
		if((cdr->dir.value != 1) && (cdr->dir.value != 0))
		{
			OLM_E(("Error in CDR for ((cdr->dir(%ld) != 1) && (cdr->dir != 0))", cdr->dir.value));
			return false;
		}


		return true;
	}


	bool getCDRFromLine_MX( char *line, samson::system::UInt*node, CDR* cdr )
	{
		//LINE   --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
		//Note: multihtread save implementation

		GET_CDRS_INIT_NO_MX

		GET_CDRS_NEXT_FIELD     //Unused field

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_NUMBER( node->value )

		GET_CDRS_NEXT_FIELD     //Unused field

		GET_CDRS_NEXT_FIELD
		pos_field+=3; // Skip 3 characters of this number
		GET_CDRS_GET_NUMBER( cdr->node.value )

		GET_CDRS_NEXT_FIELD     //Unused field

		GET_CDRS_NEXT_FIELD

/*
		cdr->date.day     = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year    = CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );
*/

		GET_CDRS_NEXT_FIELD     //Unused field

/*
		cdr->time.hour    = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->time.minute  = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->time.seconds = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );
*/

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_DURATION(cdr->duration)


		//Global Checking...
		if(cdr->node.value <= 0)        return false;
		if(node->value <= 0)      return false;
		if(node->value == cdr->node.value)  return false;

		return true;
	}


	bool getCDRFromLine_JAJAH( char *line, samson::system::UInt*node, CDR* cdr )
	{
		//HEADER --> "CALL ID|MemberA_ID|MemberA_Phone|MemberB_Phone|Date&Time|Duration|Type"
		//LINE --> "173731833|182385|390817917344|393333303646|2010-01-01 00:00:00|0|SMS\n"
		//Note: multihtread save implementation

		//This function in the Jajah format yields an output that doesn't contain the member ID of the MemberB, only the phone number.
		//Thus, an additional step is necessary after this parsing. For that purpose, the key of this dataset will be the MemberB Phone number
		//instead of the MemberA userID. thanks to this, the set can be combined with a [UserPhone - User] Data set in a Reduce operation
		//to replace the MemberB Phone for the MemberB userID, if exists.

		GET_CDRS_INIT_NO_MX

		GET_CDRS_NEXT_FIELD
		//First field useless

		GET_CDRS_NEXT_FIELD //MemberA ID
		GET_CDRS_GET_NUMBER( cdr->node.value )

		GET_CDRS_NEXT_FIELD
		//MemberA_Phone not used by the moment. Jajah recognizes users by memberID

		GET_CDRS_NEXT_FIELD //MemberB Phone
		GET_CDRS_GET_NUMBER( node->value )


		GET_CDRS_NEXT_FIELD //Date and time

/*
		cdr->date.year    = CHAR_TO_INT( line[pos_field+2] ) *10 + CHAR_TO_INT( line[pos_field+3] );
		cdr->date.month   = CHAR_TO_INT( line[pos_field+5] ) *10 + CHAR_TO_INT( line[pos_field+6] );
		cdr->date.day   = CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );


		cdr->time.hour    = CHAR_TO_INT( line[pos_field+11] ) *10 + CHAR_TO_INT( line[pos_field+12] );
		cdr->time.minute  = CHAR_TO_INT( line[pos_field+14] ) *10 + CHAR_TO_INT( line[pos_field+15] );
		cdr->time.seconds = CHAR_TO_INT( line[pos_field+17] ) *10 + CHAR_TO_INT( line[pos_field+18] );
*/


		GET_CDRS_NEXT_FIELD //Duration
		GET_CDRS_GET_DURATION(cdr->duration)


		//Global Checking...
		if(cdr->node.value <= 0)        return false;
		if(node->value <= 0)      return false;
		if(node->value == cdr->node.value)  return false;

		return true;
	}

	bool getCDRFromLine_TASA( char *line, samson::system::UInt*node, CDR* cdr )
	{
		//LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
		//Note: multihtread save implementation

		GET_CDRS_INIT_NO_MX

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_NUMBER( node->value )

		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_NUMBER( cdr->node.value )


		GET_CDRS_NEXT_FIELD

/*		cdr->date.day   = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year    = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );

		cdr->time.hour    = 0 ;
		cdr->time.minute  = 0 ;
		cdr->time.seconds = 0 ;
*/


		GET_CDRS_NEXT_FIELD
		GET_CDRS_GET_DURATION(cdr->duration)

		cdr->dir.value    = 1 ;

		//Global Checking...
		if(cdr->node.value <= 0)        return false;
		if(node->value <= 0)      return false;
		if(node->value == cdr->node.value)  return false;

		return true;
	}











	void init(samson::KVWriter *writer)
	{
		std::string format = environment->get( SNA_PARAMETER_CDR_FORMAT, SNA_PARAMETER_CDR_FORMAT_DEFAULT);

		//OLM_M(("Enters: init()"));



		if( format.compare("TME")==0 )
			_getCDRFunction = &parse_cdrs::getCDRFromLine_TME;
		else if( format.compare("JAJAH")==0 )
			_getCDRFunction = &parse_cdrs::getCDRFromLine_JAJAH;
		else if( format.compare("MX")==0 )
			_getCDRFunction = &parse_cdrs::getCDRFromLine_MX;
		else if( format.compare("TASA")==0 )
			_getCDRFunction = &parse_cdrs::getCDRFromLine_TASA;
		else if( format.compare("TEMM_VOZ")==0 )
			_getCDRFunction = &parse_cdrs::getCDRFromLine_TEMM_VOZ_15fields;
		else if( format.compare("TEMM_SMS")==0 )
			_getCDRFunction = &parse_cdrs::getCDRFromLine_TEMM_SMS;
		else if( format.compare("TEMM_MMS")==0 )
			_getCDRFunction = &parse_cdrs::getCDRFromLine_TEMM_MMS;
		else {
			OLM_E(("Error. Format not supported\n"));
			exit(1);;
		}


	}


	void parseLines( char *line, samson::KVWriter *writer )
	{
		//MRDatas to emit
		samson::system::UInt number;
		CDR cdr;

		//ss:system::Date previous_date;    //Date of the last CDR
		//previous_date.day.value = 0;      //Make sure it is not the same as anything

		if( (this->*_getCDRFunction)(line , &number ,  &cdr ) )
		{
			//Compute allways week of the day?
			//      if ( !cdr.date.isEqual(&previous_date)   ) {
			//        cdr.date.computeDayOfTheWeek();
			//        previous_date.copyFrom(&cdr.date);
			//      } else {
			//        cdr.date.week_day = previous_date.week_day;
			//      }

			/*
			cdr.date.week_day = 0;
			*/

			writer->emit(0, &number, &cdr);

		}
		else
		{
			//OLM_E(("Error parsing line:'%s' for CDR", line));
			;
		}
	}


	void run( char *data , size_t length , samson::KVWriter *writer )
	{
		//Datas to emit
		samson::system::UInt number;
		CDR cdr;

		size_t offset = 0;
		size_t line_begin = 0;

		while( offset < length )
		{

			if( data[offset] == '\n')
			{
				data[offset] = '\0';

				parseLines(data+line_begin , writer);

				line_begin = offset+1;
			}
			++offset;
		}

	}
};


} // end of namespace samson
} // end of namespace snalight

#endif
