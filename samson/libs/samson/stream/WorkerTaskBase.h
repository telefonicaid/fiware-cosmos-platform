#ifndef _H_SAMSON_QUEUE_TASK_BASE
#define _H_SAMSON_QUEUE_TASK_BASE

#include <set>
#include <set>                       // std::set
#include <sstream>

#include "au/string.h"               // au::Format

#include "samson/common/MessagesOperations.h"
#include "samson/common/samson.pb.h"

#include "engine/ProcessItem.h"      // engine::ProcessItem

#include "samson/stream/Block.h"     // samson::Stream::Block
#include "samson/stream/BlockList.h" // stream::BlockList
#include "samson/stream/BlockListContainer.h"


namespace samson {
namespace stream {
class Block;

/*
 *
 * WorkerTaskBase
 *
 * Base class for WorkerTask and WorkerSystemTask
 *
 */

class WorkerTaskBase {
  // Id of the operation
  size_t id_;


  // State information
  std::string task_state_;

  // Falg to determine if this task is ready ( all blocks in memory )
  bool ready_;


protected:

  // Container for all input/output blocks
  BlockListContainer block_list_container_;

  // Cronometers
  au::Cronometer creation_cronometer_;
  au::CronometerSystem cronometer_;

public:

  // Constructor and destructor
  WorkerTaskBase(size_t id);
  virtual ~WorkerTaskBase();

  // Add blocks for input
  void add_input(int channel, BlockPointer block, KVRange range, KVInfo info);

  // Add blocks for output ( generated by running the operation )
  void add_output(int channel, BlockPointer block, KVRange range, KVInfo info);

  // Funciton to check if all the blocks are in memory
  bool is_ready();

  // Get the id of this task
  size_t get_id();

  // set & get over queue_task_state
  void SetTaskState(const std::string& _queue_task_state);
  std::string task_state();

  // Debug string to list last operations executed
  virtual std::string str() = 0;

  // Method to fill records with my information ( tables on delilah )
  virtual void fill(samson::gpb::CollectionRecord *record, const Visualization& visualization) = 0;
};
}
}

#endif // ifndef _H_SAMSON_QUEUE_TASK_BASE

