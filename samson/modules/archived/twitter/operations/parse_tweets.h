/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_twitter_parse_tweets
#define _H_SAMSON_twitter_parse_tweets

#include <algorithm>
#include <set>


#include <samson/module/samson.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/UInt.h>
#include "logMsg/logMsg.h"


namespace samson{
namespace twitter{


class parse_tweets : public samson::Parser
{

	samson::system::String key;
	samson::system::UInt value;

	std::set<std::string> stopwords_en;
	std::set<std::string> stopwords_es;
	std::set<std::string> stopwords_pt;
	std::set<std::string> stopwords_fr;
	std::set<std::string> stopwords_it;
	std::set<std::string> stopwords_de;

public:


	//  INFO_MODULE
	// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
	// Please, do not remove this comments, as it will be used to check consistency on module declaration
	//
	//  output: system.String system.UInt
	//
	//  helpLine: parse tweets with multiple views
	//  extendedHelp: 		parse tweets with multiple views
	//
	//  END_INFO_MODULE

	void init( samson::KVWriter *writer )
	{
	    std::string arr_stopwords_en[] = {"i", "you", "he", "she", "it", "we", "they", "not", "yes", "no", "me", "him", "her", "them", "my", "your", "his", "us", "their", "the", "a", "an", "to", "on", "in", "of", "for", "if", "that", "and", "or", "this", "these", "those", "with", "is", "isn't", "do", "did", "does", "am", "are", "i'm", "at", "was", "were"};
        std::string arr_stopwords_es[] = {"yo", "tu", "él", "ella", "nosotros", "vosotros", "ellos", "ellas", "no", "si", "sí", "mi", "ti", "se", "nos", "os", "el", "la", "los", "las", "un", "uno", "una", "a", "de", "y", "o", "que", "por", "para", "del", "en", "con", "desde", "entre", "hacia", "hasta", "para", "según", "ni", "más", "ya", "su", "muy", "lo", "le", "les", "es", "como", "esto", "esta", "estos", "este", "esto"};
        std::string arr_stopwords_pt[] = {"de", "e", "o", "a", "os", "as", "ter", "que", "eu", "mas", "para", "da", "na", "na", "nos", "nas", "pra", "por", "me", "em", "mais"};
        std::string arr_stopwords_fr[] = {"je", "tu", "il", "elle", "nous", "vous", "ils", "elles", "moi", "toi", "soi", "mon", "ma", "ton", "ta", "son", "sa", "le", "la", "les", "no", "pas", "à", "et", "ou", "que", "ce", "ces", "c'est", "pour", "par", "ce", "sur", "dans", "sous", "de", "en", "uns", "une", "unes"};
        std::string arr_stopwords_it[] = {"io", "e", "che", "chi", "de", "di", "un", "li", "le", "loro", "si", "non", "nostra", "nostri", "la", "il", "a", "quasi"};
        std::string arr_stopwords_de[] = {"ich", "und", "bei", "jetzt", "das", "den", "die", "mich", "dich", "du", "fur", "der", "so", "is", "wir", "um", "wird", "ohne", "des", "auch", "nein", "ja", "zum", "im"};

        for (unsigned int i = 0; (i < (sizeof(arr_stopwords_en)/sizeof(arr_stopwords_en[0]))); i++)
        {
            stopwords_en.insert(arr_stopwords_en[i]);
        }
        for (unsigned int i = 0; (i < (sizeof(arr_stopwords_es)/sizeof(arr_stopwords_es[0]))); i++)
        {
            stopwords_es.insert(arr_stopwords_es[i]);
        }
        for (unsigned int i = 0; (i < (sizeof(arr_stopwords_pt)/sizeof(arr_stopwords_pt[0]))); i++)
        {
            stopwords_pt.insert(arr_stopwords_pt[i]);
        }
        for (unsigned int i = 0; (i < (sizeof(arr_stopwords_fr)/sizeof(arr_stopwords_fr[0]))); i++)
        {
            stopwords_fr.insert(arr_stopwords_fr[i]);
        }
        for (unsigned int i = 0; (i < (sizeof(arr_stopwords_it)/sizeof(arr_stopwords_it[0]))); i++)
        {
            stopwords_it.insert(arr_stopwords_it[i]);
        }
        for (unsigned int i = 0; (i < (sizeof(arr_stopwords_de)/sizeof(arr_stopwords_de[0]))); i++)
        {
            stopwords_de.insert(arr_stopwords_de[i]);
        }

	}

	char *strnstr(char *text, const char *pattern, size_t max_length)
	{
		char cpat, ctxt;
		size_t len;

		if ((cpat = *pattern++) != '\0')
		{
			len = strlen(pattern);
			do
			{
				do
				{
					if ((max_length-- < 1) || (ctxt = *text++) == '\0')
						return (NULL);
				} while (ctxt != cpat);
				if (len > max_length)
					return (NULL);
			} while (strncmp(text, pattern, len) != 0);
			text--;
		}
		return (text);
	}

	void parseTweets(char *text, char *text_end, samson::KVWriter *writer)
	{
		char *p_tag_begin = text;
		char *p_end;

#define TAG_USER_BEGIN "user="

		if ((p_tag_begin = strnstr(p_tag_begin, TAG_USER_BEGIN, text_end - p_tag_begin)) == NULL)
		{
			//OLM_E(("page without title begin:'%s'", PAGE_TAG_TITLE_BEGIN));
			return;
		}
		p_tag_begin += strlen(TAG_USER_BEGIN);

		if ((p_end = strnstr(p_tag_begin, " ", text_end - p_tag_begin)) == NULL)
		{
			//OLM_E(("page without title end:'%s'", PAGE_TAG_TITLE_END));
			return;
		}
		//char *copia;
		//copia = strndup(p_tag_begin, p_end - p_tag_begin);
		//OLM_T(LMT_User06, ("key:%s", copia));
		//free(copia);
		std::string user(p_tag_begin, p_end - p_tag_begin);

		key.value = "topUser " + user;
		value.value = 1;
		writer->emit(0, &key, &value);

		p_tag_begin = p_end+1;

#define TAG_LANG_BEGIN "lang="

		if ((p_tag_begin = strnstr(p_tag_begin, TAG_LANG_BEGIN, text_end - p_tag_begin)) == NULL)
		{
			//OLM_E(("page without title begin:'%s'", PAGE_TAG_TITLE_BEGIN));
			return;
		}
		p_tag_begin += strlen(TAG_LANG_BEGIN);

		if ((p_end = strnstr(p_tag_begin, ": ", text_end - p_tag_begin)) == NULL)
		{
			//OLM_E(("page without title end:'%s'", PAGE_TAG_TITLE_END));
			return;
		}
		//char *copia;
		//copia = strndup(p_tag_begin, p_end - p_tag_begin);
		//OLM_T(LMT_User06, ("key:%s", copia));
		//free(copia);
		std::string lang(p_tag_begin, p_end - p_tag_begin);

		key.value = "topLang " + lang;
		value.value = 1;
		writer->emit(0, &key, &value);

        key.value = "topUserLang_" + lang + " " + user;
        value.value = 1;
        writer->emit(0, &key, &value);

		p_tag_begin = p_end+strlen(": ");


		while ((p_end = strnstr(p_tag_begin, " ", text_end - p_tag_begin)) != NULL)
		{
			std::string word(p_tag_begin, p_end - p_tag_begin);
			value.value = 1;

			if (word.empty() || (word.compare(" ") == 0))
			{
                p_tag_begin = p_end+1;
                continue;
			}

            if (word.compare("rt") == 0)
            {
                p_tag_begin = p_end+1;
                continue;
            }

            if ((word.compare(0, 1, "@") == 0) && (word.length() > 1))
            {
                if (word.compare(word.length()-1, 1, ":") == 0)
                {
                    word.erase(word.length() - 1, 1);
                }
                key.value = "topRefUser " + word;
                writer->emit(0, &key, &value);

                key.value = "topRefUserLang_" + lang + " " + user;
                value.value = 1;
                writer->emit(0, &key, &value);

                p_tag_begin = p_end+1;
                continue;
            }
            else if (word.compare(0, 7, "http://") == 0)
            {
                key.value = "topURL " + word;
                writer->emit(0, &key, &value);

                key.value = "topURLLang_" + lang + " " + user;
                value.value = 1;
                writer->emit(0, &key, &value);

                p_tag_begin = p_end+1;
                continue;
            }


			std::transform(word.begin(), word.end(), word.begin(), ::tolower);


			//OLM_T(LMT_User06, ("Va a comparar con lang=%s", lang.c_str()));
			if (lang.compare("en") == 0)
			{
			    //OLM_T(LMT_User06, ("Mira: %s por lang=%s", word.c_str(), lang.c_str()));
			    if (stopwords_en.find(word) != stopwords_en.end())
			    {
			        //OLM_T(LMT_User06, ("Salta: %s por lang=%s", word.c_str(), lang.c_str()));
			        p_tag_begin = p_end+1;
			        continue;
			    }
			}
			else if (lang.compare("es") == 0)
            {
			    //OLM_T(LMT_User06, ("Mira: %s por lang=%s", word.c_str(), lang.c_str()));
                if (stopwords_es.find(word) != stopwords_es.end())
                {
                    //OLM_T(LMT_User06, ("Salta: %s por lang=%s", word.c_str(), lang.c_str()));
                    p_tag_begin = p_end+1;
                    continue;
                }
            }
			else if (lang.compare("pt") == 0)
            {
                if (stopwords_pt.find(word) != stopwords_pt.end())
                {
                    p_tag_begin = p_end+1;
                    continue;
                }
            }
			else if (lang.compare("fr") == 0)
            {
                if (stopwords_fr.find(word) != stopwords_fr.end())
                {
                    p_tag_begin = p_end+1;
                    continue;
                }
            }
			else if (lang.compare("it") == 0)
            {
                if (stopwords_it.find(word) != stopwords_it.end())
                {
                    p_tag_begin = p_end+1;
                    continue;
                }
            }
			else if (lang.compare("de") == 0)
            {
                if (stopwords_de.find(word) != stopwords_de.end())
                {
                    p_tag_begin = p_end+1;
                    continue;
                }
            }

			key.value = "top " + word;
			writer->emit(0, &key, &value);

			key.value = "topLang_" + lang + " " + word;
			writer->emit(0, &key, &value);

			if (word[0] == '#')
			{
                key.value = "topHashTag " + word;
                writer->emit(0, &key, &value);

	            key.value = "topHashLang_" + lang + " " + word;
	            writer->emit(0, &key, &value);
			}

			p_tag_begin = p_end+1;
		}
		if (p_tag_begin < (text_end))
		{
			std::string word(p_tag_begin, text_end - p_tag_begin);
			value.value = 1;

            if (word.empty() || (word.compare(" ") == 0))
            {
                return;
            }


            if (word.compare(0, 1, "@") == 0)
            {
                key.value = "topRefUser " + word;
                writer->emit(0, &key, &value);

                return;
            }
            else if (word.compare(0, 7, "http://") == 0)
            {
                key.value = "topURL " + word;
                writer->emit(0, &key, &value);

                return;
            }

            std::transform(word.begin(), word.end(), word.begin(), ::tolower);

            //OLM_T(LMT_User06, ("Va a comparar con lang=%s", lang.c_str()));
            if (lang.compare("en") == 0)
            {
                //OLM_T(LMT_User06, ("Mira: %s por lang=%s", word.c_str(), lang.c_str()));
                if (stopwords_en.find(word) != stopwords_en.end())
                {
                    //OLM_T(LMT_User06, ("Salta: %s por lang=%s", word.c_str(), lang.c_str()));

                    return;
                }
            }
            else if (lang.compare("es") == 0)
            {
                //OLM_T(LMT_User06, ("Mira: %s por lang=%s", word.c_str(), lang.c_str()));
                if (stopwords_es.find(word) != stopwords_es.end())
                {
                    //OLM_T(LMT_User06, ("Salta: %s por lang=%s", word.c_str(), lang.c_str()));

                    return;
                }
            }
            else if (lang.compare("pt") == 0)
            {
                if (stopwords_pt.find(word) != stopwords_pt.end())
                {

                    return;
                }
            }
            else if (lang.compare("fr") == 0)
            {
                if (stopwords_fr.find(word) != stopwords_fr.end())
                {

                    return;
                }
            }
            else if (lang.compare("it") == 0)
            {
                if (stopwords_it.find(word) != stopwords_it.end())
                {

                    return;
                }
            }
            else if (lang.compare("de") == 0)
            {
                if (stopwords_de.find(word) != stopwords_de.end())
                {

                    return;
                }
            }


			key.value = "top " + word;
			writer->emit(0, &key, &value);

			key.value = "topLang_" + lang + " " + word;
			writer->emit(0, &key, &value);
		}
		return;

	}


	void run( char *data , size_t length , samson::KVWriter *writer )
	{
		size_t offset = 0;

		char *p_line_begin = data;
		char *p_line_end;
		char *p_line;

		p_line = data;

		while (offset < length)
		{

			if (*p_line == '\n')
			{
				p_line_end = p_line;
				std::string line(p_line_begin, p_line_end-p_line_begin);
				//OLM_T(LMT_User06, ("Detected: '%s'", line.c_str()));
				parseTweets(p_line_begin, p_line_end, writer);

				p_line_begin = p_line_end + 1;
				offset = p_line_begin - data;
			}


			p_line++;
		}
	}

	void finish( samson::KVWriter *writer )
	{
	}



};


} // end of namespace twitter
} // end of namespace samson

#endif
