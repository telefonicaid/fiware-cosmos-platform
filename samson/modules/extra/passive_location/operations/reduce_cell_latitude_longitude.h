
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_passive_location_reduce_cell_latitude_longitude
#define _H_SAMSON_passive_location_reduce_cell_latitude_longitude

#include "logMsg/logMsg.h"
#include <samson/module/samson.h>
#include <samson/modules/mobility/CellRecord.h>
#include <samson/modules/mobility/Record.h>
#include <samson/modules/passive_location/Cell.h>
#include <samson/modules/system/UInt.h>


namespace samson{
namespace passive_location{


class reduce_cell_latitude_longitude : public samson::Reduce
{

    samson::system::UInt32 cellId_key;         // Input key
    samson::mobility::CellRecord cell_record;  // Input record
    samson::mobility::Record record;           // Output record
    samson::passive_location::Cell cell;       // Information about cell

public:


    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: system.UInt32 mobility.CellRecord
    //  input: system.UInt32 passive_location.Cell
    //  output: system.UInt mobility.Record
    //  output: system.UInt32 mobility.CellRecord
    //
    // helpLine: Add lat-lon information to Records. Note that key at the input is cellid,key at the output user-id
    //  END_INFO_MODULE

    void init( samson::KVWriter *writer )
    {
    }

    void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
    {
        if (inputs[0].num_kvs == 0)
        {
            return;
        }

        if( inputs[1].num_kvs == 0)
        {
            cellId_key.parse(inputs[0].kvs[0]->key);
            //LM_W(("No cellInfo for cellId:%u(0x%0x) (%lu records)", cellId_key.value, cellId_key.value, inputs[0].num_kvs));

            // Non existing cell... forward input to output 1
            for ( uint64_t i = 0 ; i< inputs[0].num_kvs ; i++)
            {
                cell_record.parse( inputs[0].kvs[i]->value );
                writer->emit( 1 , &cell_record.cellId , &cell_record );
            }
            return;
        }

        cellId_key.parse(inputs[1].kvs[0]->key);

        if (inputs[1].num_kvs > 1)
        {
            LM_W(("More than one cell description for cellId:%u (%lu infos)", cellId_key.value, inputs[1].num_kvs));
        }
        //LM_M(("Emitting %lu records for cellId:%u", inputs[0].num_kvs, cellId_key.value));


        cell.parse( inputs[1].kvs[0]->value ); // Only consider the first one...

        for ( uint64_t i = 0 ; i< inputs[0].num_kvs; i++)
        {
            cell_record.parse( inputs[0].kvs[i]->value );

            // Complete the complete record
            record.userId.value = cell_record.userId.value;
            record.timestamp.value = cell_record.timestamp.value;
            record.cellId.value = cell_record.cellId.value;

            record.position.copyFrom( &cell.position );

            writer->emit( 0 , &record.userId , &record );
        }
        return;

    }

    void finish( samson::KVWriter *writer )
    {
    }



};


} // end of namespace passive_location
} // end of namespace samson

#endif
