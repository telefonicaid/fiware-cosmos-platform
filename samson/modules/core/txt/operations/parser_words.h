
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_txt_parser_words
#define _H_SAMSON_txt_parser_words


//#include "au/charset.h"

#include <samson/module/samson.h>
#include <samson/module/samson.h>
#include <samson/modules/system/SimpleParser.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/UInt.h>
#include <samson/modules/system/Void.h>
#include <iostream>

#include "logMsg/logMsg.h"

namespace samson{
namespace txt{


	class parser_words : public samson::system::SimpleParser
	{
		samson::system::String key;
		samson::system::UInt value;

	public:
		
		parser_words()
		{
            // Output value is always 1
			value.value = 1;			
		}

/*		
		bool isSeparator( char c )
		{
           // If it not a letter is a separator
		   return !au::iso_8859_is_letter( c );
		}
*/

        bool isSeparator( char c )
        {
           if( c == ' ')
              return  true;
           if( c == '\t')
              return  true;

           return false;
        }


        void parseLine( char * line, samson::KVWriter *writer )
        {
		   AU_OD(("Parsing line %s", line));
		   
           size_t len = strlen( line );
           size_t pos = 0;
           for ( size_t i = 0 ; i < (len+1) ; i++ )
           {
              if( isSeparator( line[i] ) || line[i]=='\0' )
              {
                 if( pos < i )
                 {
                    // New word
                    key.value ="";
                    key.value.append( &line[pos] ,i-pos );
                    writer->emit( 0 , &key , &value );

					AU_OD(("Emitting word %s" , key.value.c_str() ));
                 }
                 // Go to the next
                 pos = i+1;
              }
           }

        }
	};


} // end of namespace samson
} // end of namespace system

#endif
