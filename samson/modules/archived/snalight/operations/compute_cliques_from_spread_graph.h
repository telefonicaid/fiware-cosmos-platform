
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_compute_cliques_from_spread_graph
#define _H_SAMSON_sna_compute_cliques_from_spread_graph



#include <samson/module/samson.h>
#include "CliquesSolver.h"							// CliquesSolver
#include <samson/modules/system/UInt.h>				// samson::system::UInt
#include <samson/modules/system/Void.h>				// samson::system::Void

#include <samson/modules/snalight/Node.h>				// samson::snalight::Node

#include <samson/modules/snalight/Vector_Node.h>		// samson::snalight::Vector_Node
#include "samson/modules/snalight/Vector_Clique.h"		// samson::snalight::Vector_Clique





namespace samson{
namespace snalight{


	class compute_cliques_from_spread_graph : public samson::Reduce
	{

		CliquesSolver cliquesSolver ;
		samson::system::UInt node_id ;
		
		samson::snalight::Node node ;
		samson::snalight::Vector_Node neighbours ;
		samson::snalight::Vector_Clique cliques ;
		
		samson::system::Void void_data ;
		
		
	public:


                void init (samson::KVWriter *writer)
                {
                        OLM_T(LMT_User06, ("compute_cliques_from_spread_graph::init()"));

                }

		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
			
			// Get the nodeId of the node we are processing (key value)
			samson::system::UInt node_id;		 
			node_id.parse( inputs[0].kvs[0]->key );  
			
			//OLM_T(LMT_User06, ("compute_cliques_from_spread_graph, Enters key:%lu, inputs[0].num_kvs:%lu\n", node_id.value, inputs[0].num_kvs));


			//Get all the values that are the neighbours nodes (if we receive the keynode, we store in a separate element "node")
			neighbours.itemsSetLength(inputs[0].num_kvs);	

			//OLM_T(LMT_User06, ("node_id:%ld neighbours length: %d", node_id.value, inputs[0].num_kvs));

			size_t pos_neighbours = 0;
			for (size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			{
				neighbours.items[pos_neighbours].parse( inputs[0].kvs[i]->value );
				
				//Recover pointer to the keyNode!
				if ( neighbours.items[pos_neighbours].id.value == node_id.value )
				{
					//OLM_T(LMT_User06, ("node_id:%ld == neighbours.items[%ld] at i = %d", node_id.value, pos_neighbours, i));
					node.copyFrom(&neighbours.items[pos_neighbours]);
				}
				else
				{
					//OLM_T(LMT_User06, ("node_id:%ld != neighbours.items[%ld](%ld) at i = %d", node_id.value, pos_neighbours, neighbours.items[pos_neighbours].id.value, i));
					pos_neighbours++;
				}
				
			}
			//Make sure we have the correct number of nodes in this vector
			// As we are also emitted in the map, there is one less neighbour than kvs

			// Before, we check with an if(), in order to be able to write the neighbours
			if (pos_neighbours != (inputs[0].num_kvs-1))
			{
				OLM_E(("node_id:%ld, Error: Number of pos_neighbours(%ld) != (inputs[0].num_kvs-1)(%d)", node_id.value, pos_neighbours, (inputs[0].num_kvs-1)));
				for (int k=0;k<neighbours.items_length;k++)
				{
					OLM_E(("MASP: neighbour(%d) valor(%ld)", k, neighbours.items[k].id.value));
				}
				exit(1);
			}
			else
			{
				//OLM_T(LMT_User06, ("node_id:%ld, Number of pos_neighbours(%ld) == (inputs[0].num_kvs-1)(%d)", node_id.value, pos_neighbours, (inputs[0].num_kvs-1)));
			}
			
			// Only emmit cliques of "Telefonica" contacts
			//if( node.isExtern() )
			//	return;	
			
			//Get the connection matrix to solve cliques with the rest of elements ( keyNode not included )
			//OLM_T(LMT_User01, ("node_id:%ld, Calling cliquesSolver.clearConnectionsMatrix()", node_id.value));
			cliquesSolver.clearConnectionsMatrix( inputs[0].num_kvs-1 );
			for (size_t i = 0 ; i < pos_neighbours ; i++)
			{
				for (size_t j = i+1 ; j < pos_neighbours ; j++)
				{
					//OLM_T(LMT_User06, ("node_id:%ld, Examining connection between (%ld,%ld)(%ld,%ld), weight:%.2f", node_id.value, i, j, neighbours.items[i].id.value, neighbours.items[j].id.value, neighbours.items[i].weightOfLinkWithId( neighbours.items[j].id.value )));
					if (neighbours.items[i].weightOfLinkWithId( neighbours.items[j].id.value ) >= 1.0 )
					{
						cliquesSolver.setConnection( i , j );
					}
				}
			}
			
			//OLM_T(LMT_User06, ("compute_cliques_from_spread_graph, Before solveCliques for key:%lu\n", node_id.value));

			
			//Solve the cliques
			cliquesSolver.solveCliques();
			//OLM_T(LMT_User06, ("node_id:%ld, cliquesSolver.num_solutions: %d", node_id.value, cliquesSolver.num_solutions));
			//OLM_T(LMT_User06, ("compute_cliques_from_spread_graph, After solveCliques for key:%lu with cliquesSolver.num_solutions: %d\n", node_id.value, cliquesSolver.num_solutions));

			
			// For each solution, emit the output only if we are the smallest element
			for (int i = 0 ; i  < cliquesSolver.num_solutions ; i++)
			{
				
				// Check if we have to publish ( only if we are the smallest element)
				int pos_first = cliquesSolver.solutions[i].nodes[0];
				size_t first_element = neighbours.items[pos_first].id.value;
				
				
				if( node.id < first_element )	// If you are smaller than the first sub-clique, you should publish it
				{
					//OLM_T(LMT_User06, ("node_id:%ld, Emits clique because node.id(%ld) < first_element(%ld)", node_id.value, node.id.value, first_element));

					samson::snalight::Clique clique;
					clique.nodesSetLength( cliquesSolver.solutions[i].num_nodes+1 );
					
					//Add the key-node
					clique.nodes[0] = node.id;
					
					for (int j = 0 ; j < cliquesSolver.solutions[i].num_nodes ; j++)
					{
						int pos = cliquesSolver.solutions[i].nodes[j];
						clique.nodes[1+j] = neighbours.items[pos].id;
					}
					
					//Emit the clique
					writer->emit(0,&clique, &void_data);
					
				}
				else
				{
					//OLM_T(LMT_User06, ("node_id:%ld, Do NOT emit clique because node.id(%ld) >= first_element(%ld)", node_id.value, node.id.value, first_element));

				}
				
			}
			//OLM_T(LMT_User06, ("compute_cliques_from_spread_graph, Exits key:%lu, inputs[0].num_kvs:%lu\n", node_id.value, inputs[0].num_kvs));

			
		}


	};


} // end of namespace samson
} // end of namespace snalight

#endif
