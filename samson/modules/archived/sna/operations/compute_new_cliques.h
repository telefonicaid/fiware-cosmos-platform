/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_compute_new_cliques
#define _H_SAMSON_sna_compute_new_cliques


#include <samson/module/samson.h>


namespace samson{
namespace sna{


	class compute_new_cliques : public samson::Reduce
	{
		CliquesSolver cliquesSolver ;



	public:
		void init(samson::KVWriter *writer)
		{
			cliquesSolver.min_nodes_in_solution = 1;	//All solution as individual cliques
		}

		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
			Clique reduce_input_clique ;
			Vector_Clique_Node reduce_input_nodes_clique ;
			Vector_Clique vector_Clique ;

			if( inputs[0].num_kvs == 0)
				return;

			if ( inputs[0].num_kvs > 50)
				return;

			//Key clique
			reduce_input_clique.parse( inputs[0].kvs[0]->key );	//Key clique in the reduce phase

			//Get cliques involved in this computation
			reduce_input_nodes_clique.itemsSetLength(0);

			Clique_Node tmp_node_clique;
			for (size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			{
				tmp_node_clique.parse(inputs[0].kvs[i]->value);

				//Do not add yourself
				if( ! reduce_input_clique.isEqual( &tmp_node_clique.clique) )
					reduce_input_nodes_clique.itemsAdd()->copyFrom(&tmp_node_clique);
			}

			if ( reduce_input_nodes_clique.items_length != (inputs[0].num_kvs-1))
			{
				OLM_E(("Error: reduce_input_nodes_clique.items_length(%d) != (inputs[0].num_kvs-1)(%d)", reduce_input_nodes_clique.items_length, inputs[0].num_kvs-1));
				exit(1);
			}


			//Compute the cross connections
			//Get the connection matrix to solve cliques with the rest of elements ( keyNode not included )
			cliquesSolver.clearConnectionsMatrix( reduce_input_nodes_clique.items_length );
			for (int i = 0 ; i < reduce_input_nodes_clique.items_length ; i++)
			{
				Clique_Node *node_clique_i  = &reduce_input_nodes_clique.items[i];

				for (int j = 0 ; j < node_clique_i->links_length ; j++)
				{
					Clique *clique_i_j = &node_clique_i->links[j].clique;

					for ( int k=0 ; k < reduce_input_nodes_clique.items_length ; k++ )
						if (k!=i)
						{
							Clique_Node *node_clique_k  = &reduce_input_nodes_clique.items[k];

							if( clique_i_j->isEqual( &node_clique_k->clique ) )
								cliquesSolver.setConnection(i, k);
						}
				}

			}

			//Solve the cliques
			cliquesSolver.solveCliques();

			//Solutions....
			if( cliquesSolver.num_solutions == 0 )
			{
				//You alone
				vector_Clique.itemsSetLength(0);
				vector_Clique.itemsAdd()->copyFrom(&reduce_input_clique);

				writer->emit(0, &reduce_input_clique, &vector_Clique);
			}
			else
			{


				for (int i = 0; i < cliquesSolver.num_solutions ; i++)
				{

					vector_Clique.itemsSetLength(0);
					std::vector <uint> nodes;	//List of nodes involved in the "final clique"

					//Add the elements of the "key" clique
					for (int c = 0 ; c < reduce_input_clique.nodes_length ; c++)
						nodes.push_back( reduce_input_clique.nodes[c].value );

					vector_Clique.itemsAdd()->copyFrom(&reduce_input_clique);



					bool publish = true;	//Flag to indicate if this final clique should be published

					//Publish only if we are the "first" clique component
					for ( int j = 0 ; j < cliquesSolver.solutions[i].num_nodes ; j++ )
					{
						int clique_pos = cliquesSolver.solutions[i].nodes[j];

						//Get the clique to fuse
						Clique *new_clique = &reduce_input_nodes_clique.items[ clique_pos ].clique;

						if( reduce_input_clique.cliqueCompare( new_clique ) > 0 )
							publish = false;

						for (int c = 0 ; c < new_clique->nodes_length ; c++)
							nodes.push_back( new_clique->nodes[c].value );

						vector_Clique.itemsAdd()->copyFrom(new_clique);
					}

					if( publish )
					{
						//Sort and remove duplicates...
						std::sort( nodes.begin() , nodes.end() );
						nodes.erase(unique(nodes.begin(), nodes.end()), nodes.end());

						Clique clique;
						for ( std::vector<uint>::iterator iter = nodes.begin() ; iter < nodes.end() ; iter++)
							clique.nodesAdd()->value = *iter;

						writer->emit(0, &clique , &vector_Clique);
					}
				}
			}
		}


	};


} // end of namespace samson
} // end of namespace sna

#endif
