/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_select_nodes_from_graph
#define _H_SAMSON_sna_select_nodes_from_graph


#include <samson/module/samson.h>

#include "sna_environment_parameters.h"

namespace samson{
namespace sna{


	class select_nodes_from_graph : public samson::Map
	{
		std::vector<uint> nodes ;
		bool selecting_customer_nodes ;

	public:

		void init(samson::KVWriter *writer)
		{

		  selecting_customer_nodes = false;

		  std::string telefonica_nodes = environment->get(SNA_FLAG_TELEFONICA_NODES, SNA_FLAG_TELEFONICA_NODES_DEFAULT);

		  if (telefonica_nodes.compare(SNA_FLAG_TELEFONICA_NODES_TRUE) == 0)
		  {
			  selecting_customer_nodes = true;
		  }
		  else
		  {
			  bool reading_nodes = false;
			  std::string nodes = environment->get(SNA_PARAMETER_NODES, SNA_PARAMETER_NODES_DEFAULT);

			  if (nodes.compare(SNA_PARAMETER_NODES_DEFAULT) == 0)
			  {
				  return;
			  }
			  reading_nodes =true;

			  const char *p_line = nodes.c_str();
			  char *p_sep;

			  while ((p_sep = (char *) strchr(p_line, ';')) != NULL)
			  {
				  *p_sep = '\0';
				  nodes.push_back( atoll(p_line));
				  p_line = p_sep+1;
			  }
			  nodes.push_back( atoll(p_line));
		  }
		}

		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
			  samson::system::UInt nodeId;
			  Node node;

			  if( selecting_customer_nodes )
			  {
			    for (size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			    {
			      nodeId.parse(inputs[0].kvs[i]->key);
			      node.parse(inputs[0].kvs[i]->value);

			      if( !node.isExtern() )
			        writer->emit(0, &nodeId, &node);
			    }
			  }
			  else
			  {

			    // Selecting some nodes

			    for (size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			    {
			      nodeId.parse(inputs[0].kvs[i]->key);

			      if ( std::find( nodes.begin(), nodes.end(), nodeId.value ) != nodes.end() )
			      {
			        node.parse(inputs[0].kvs[i]->value);
			        writer->emit(0, &nodeId, &node);
			      }
			    }


			  }
		}


	};


} // end of namespace samson
} // end of namespace sna

#endif
