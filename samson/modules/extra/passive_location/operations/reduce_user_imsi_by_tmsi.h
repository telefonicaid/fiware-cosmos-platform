
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_passive_location_reduce_user_imsi_by_tmsi
#define _H_SAMSON_passive_location_reduce_user_imsi_by_tmsi


#include <samson/module/samson.h>
#include <samson/modules/passive_location/CompleteTMSI.h>
#include <samson/modules/passive_location/Record.h>
#include <samson/modules/system/UInt.h>


namespace samson{
namespace passive_location{


class reduce_user_imsi_by_tmsi : public samson::Reduce
{

    samson::passive_location::CompleteTMSI completeTMSI;    // Input key
    samson::passive_location::Record record;                // Input value
    samson::passive_location::IMSIbyTime imsiTime;                              // Input value of the translation table

    uint64_t  record_timespan;
    time_t now;
    uint64_t timespanTMSI;

public:


    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: passive_location.CompleteTMSI passive_location.Record
    //  input: passive_location.CompleteTMSI passive_location.IMSIbyTime
    //  output: system.UInt passive_location.Record
    //	output: passive_location.CompleteTMSI passive_location.Record
    //  output: system.UInt passive_location.Record
    //
    // helpLine: Extract imsi info from tmsi_imsi table, based on previous records
    //  END_INFO_MODULE

    void init( samson::KVWriter *writer )
    {
        record_timespan = environment->getSizeT("pl.record_retry.timespan", 0);
        //LM_M(("pl.record_retry.timespan:%lu", record_timespan));
        if ( record_timespan != 0)
        {
            now = time(NULL);
        }

        timespanTMSI = environment->getSizeT("pl.TMSI.timespan", 0);
    }

    void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
    {
        if (inputs[0].num_kvs == 0)
        {
            return;
        }

        if( inputs[1].num_kvs == 0)
        {
            completeTMSI.parse(inputs[0].kvs[0]->key);
            //LM_W(("No userInfo for tmsi:%lu,%u (%lu records)", completeTMSI.tmsi.value, completeTMSI.LAC.value, inputs[0].num_kvs));

            // Non existing user... forward input to output 1
            for ( uint64_t i = 0 ; i< inputs[0].num_kvs ; i++)
            {
                record.parse( inputs[0].kvs[i]->value );
                // Emitted by imei, in order to try later a second option
                // But it has not been possible to recover MSISDN from IMEI, if not successful with IMSI,
                // so we just dump all the records, and remove the join with IMEI key
                //                    if (record.imei.value != 0)
                //                    {
                //                        writer->emit( 1 , &record.imei , &record );
                //                    }
                //                    else
                //                    {
                //                        writer->emit(2, &completeTMSI.tmsi, &record);
                //                    }
                if ((record_timespan == 0) || ((now - record.timestamp.value) < (int64_t)record_timespan))
                {
                    //LM_M(("Emit record for reprocessing, TMSI:%lu", completeTMSI.tmsi.value));
                    writer->emit( 1 , &completeTMSI , &record );
                }
                else
                {
                    //LM_M(("Emit record to forget, TMSI:%lu", completeTMSI.tmsi.value));
                    writer->emit(2, &completeTMSI.tmsi, &record);
                }
            }
            return;
        }

        completeTMSI.parse(inputs[1].kvs[0]->key);

        //            if (completeTMSI.tmsi.value == 0)
        //            {
        //                LM_W (("Records with tmsi == 0, inputs[0].num_kvs:%lu, inputs[1].num_kvs:%lu", inputs[0].num_kvs, inputs[1].num_kvs));
        //            }

        if (inputs[1].num_kvs > 1)
        {
            LM_W(("More than one user description for tmsi:%lu,%u (%lu infos)", completeTMSI.tmsi.value, completeTMSI.LAC.value, inputs[1].num_kvs));
            // We should look for the newest info...
            // But easiest if we are sure we only have one
            for (uint64_t i = 0; (i < inputs[1].num_kvs); i++)
            {
                imsiTime.parse(inputs[1].kvs[i]->value);
                LM_M(("TMSI: tmsi:%lu, LAC:%d, imsi:%lu, time:%s", completeTMSI.tmsi.value, completeTMSI.LAC.value, imsiTime.imsi.value, imsiTime.timestamp.str().c_str()));
            }

        }

        imsiTime.parse( inputs[1].kvs[inputs[1].num_kvs-1]->value );

        //LM_M(("Emitting %lu records for imsi:%lu", inputs[0].num_kvs, imsi_key.value));

        for ( uint64_t i = 0 ; i< inputs[0].num_kvs; i++)
        {
            record.parse( inputs[0].kvs[i]->value );

            // Complete the complete record
            record.imsi.value = imsiTime.imsi.value;

            //                if (record.imsi.value == 0)
            //                {
            //                    LM_W(("Found imsi:%lu == 0 (tmsi:%lu,%u)", record.imsi.value, completeTMSI.tmsi.value, completeTMSI.LAC.value));
            //                }
            //                LM_W(("Resolved imsi:%lu for (tmsi:%lu,%u)", record.imsi.value, completeTMSI.tmsi.value, completeTMSI.LAC.value));

            if ((timespanTMSI == 0) || ((record.timestamp.value - imsiTime.timestamp.value) < (int64_t)timespanTMSI))
            {
                writer->emit( 0 , &record.imsi , &record );
            }
            else
            {
                //LM_M(("Emit record to forget, TMSI:%lu", completeTMSI.tmsi.value));
                writer->emit(2, &completeTMSI.tmsi, &record);
            }
        }
        return;

    }

    void finish( samson::KVWriter *writer )
    {
    }



};


} // end of namespace passive_location
} // end of namespace samson

#endif
