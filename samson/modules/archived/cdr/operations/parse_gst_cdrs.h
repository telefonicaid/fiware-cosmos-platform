
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_cdr_parse_gst_cdrs
#define _H_SAMSON_cdr_parse_gst_cdrs


#include <stdint.h>

#include <samson/module/samson.h>
#include <samson/modules/system/Time.h>
#include <samson/modules/system/UInt.h>
#include "cdr_parse_fields.h"
#include "cdr_environment_parameters.h"


namespace samson{
namespace cdr{


	class parse_gst_cdrs : public samson::Parser
	{

	public:
		int min_digit;
		int max_digit;
		int old_date;


		bool (parse_gst_cdrs ::*_getCDRFunction)( char*line, samson::system::UInt *node, gstCdr* info,  int max_digit, int min_digit, bool old);



#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

output: system.UInt cdr.gstCdr

helpLine: Parse txt-file of Gasset CDRS in  different formats.
extendedHelp: 		Parse txt-file of CDRS in  different formats.
	This is a generic parse for different formats. Please, specify with the -format <format>
	Use the -old_date to swich the format to old CDRs dates (01/01/2010)
	Suported formats:
	TEMM:   --> 33F43061B47A63|6691159047|33F43061B47A63|0446691557000|2|20100101|01:57:39|4|NOROAMI

#endif // de INFO_COMMENT


#if 0

		bool getCDRFromLine_TME( char *line, samson::system::UInt*node, gstCdr* cdr, int max_digit, int min_digit, bool old )
		{
			//LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
			//Note: multihtread save implementation



			GET_CDRS_INIT

			GET_CDRS_NEXT_FIELD
			//First field useless

			GET_CDRS_NEXT_FIELD
			GET_CDRS_GET_NUMBER( node->value )

			GET_CDRS_NEXT_FIELD
			GET_CDRS_GET_NUMBER( cdr->node.value )


			GET_CDRS_NEXT_FIELD

			// Assuming years after 2000
			timeExpanded.tm_mday = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
			timeExpanded.tm_mon = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] ) - 1;
			timeExpanded.tm_year = 100 + CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );

			timeExpanded.tm_hour = CHAR_TO_INT( line[pos_field+9] ) *10 + CHAR_TO_INT( line[pos_field+10] );
			timeExpanded.tm_min = CHAR_TO_INT( line[pos_field+12] ) *10 + CHAR_TO_INT( line[pos_field+13] );
			timeExpanded.tm_sec = CHAR_TO_INT( line[pos_field+15] ) *10 + CHAR_TO_INT( line[pos_field+16] );

			cdr->timeUnix.getTimeUTCFromCalendar(&timeExpanded);
			//cdr->week_day.value = timeExpanded.tm_wday;


			GET_CDRS_NEXT_FIELD
			GET_CDRS_GET_DURATION(cdr->duration.value)


			//Global Checking...
			if(cdr->node.value <= 0)        return false;
			if(node->value <= 0)      return false;
			if(node->value == cdr->node.value)  return false;

			return true;
		}
#endif

		///(TEMM specific)
		///Function to parse a line and convert it into
		///a CDR structure.
		///
		///@param line Pointer to the line to be parsed.
		///@param cdr Pointer to the CDR structure.
		///@param max_digit number of max possible digit in the phone number
		///@param min_digit number of min digit permited in the phone number
		///
		///@return TRUE if successful parsing, FALSE in case
		///   of error.
		bool getCDRFromLine_TEMM_VOZ( char *line, samson::system::UInt*node, gstCdr* cdr, int max_digit, int min_digit, bool old )
		{
			//HEADER --> "CELL_START|PHONE1|CELL_FINISH|PHONE2|DIR|DATE|TIME|DURATION"
			//LINE   --> "33F43052167D16|2221435146|33F43052167D16|0442221472843|2|04/01/2010|17:21:07|22"
			//Note: multithread save implementation

			  unsigned int _pos=0;
			  unsigned int _pos_field=0;
			  uint32_t _cellId = 0;
			  //unsigned int _mobScope;

			  struct tm timeExpanded;


			  try {
				    cdrGetNextField(line, &_pos, &_pos_field);
				    cdrStrCellToInt( line+_pos_field, &_cellId );

				    cdrGetNextField(line, &_pos, &_pos_field);
				    cdrPhoneToNumber(line+_pos_field, &(node->value), max_digit);

				    cdrGetNextField(line, &_pos, &_pos_field);
				    if(_cellId == 0){
				      cdrStrCellToInt( line+_pos_field, &_cellId );
				    }

				    cdr->cellId.value = _cellId;

				    cdrGetNextField(line, &_pos, &_pos_field);
				    cdrPhoneToNumber(line+_pos_field, &(cdr->phone.value), max_digit);

				    cdrGetNextField(line, &_pos, &_pos_field);
				    GST_get_cdrs_number( line, &(cdr->dir.value), _pos_field );

				    if(cdr->dir.value == 2){
				      cdr->dir.value = 0;
				    }

				    cdrGetNextField(line, &_pos, &_pos_field);
				    cdrStrDateToStructure( line+_pos_field, &timeExpanded, old );

				    cdrGetNextField(line, &_pos, &_pos_field);
				    cdrStrTimeToStructure( line+_pos_field, &timeExpanded );

					cdr->timeUnix.getTimeUTCFromCalendar(&timeExpanded);
					//cdr->week_day.value = timeExpanded.tm_wday;


				    cdrGetNextField(line, &_pos, &_pos_field);
				    GST_get_cdrs_number( line, &(cdr->duration.value), _pos_field );

				    cdr->type = 0;

				    cdrGetNextField(line, &_pos, &_pos_field);
				    cdrStrScopeToInt_MX( line+_pos_field, &(cdr->mobScope.value) );

				    //Global Checking...
				    unsigned int min_digit_count_mask = GST_calculate_mask(min_digit);
				    if(cdr->phone.value <= min_digit_count_mask)    throw false;
				    if(node->value <= min_digit_count_mask)  throw false;
				    if(node->value == cdr->phone.value)             throw false;
				    if((cdr->dir.value != 1) && (cdr->dir.value != 0))   throw false;

				  }catch( ... ){
				      OLM_D(("Line rejected: '%s'\n", line));
				    return false;
				  }

				  return true;
		}

#if 0
		bool getCDRFromLine_TEMM_VOZ_15fields( char *line, samson::system::UInt*node, CDR* cdr, int max_digit, int min_digit, bool old )
		{
			//HEADER --> "CELL_START|PHONE1|CELL_FINISH|PHONE2|DIR|DATE|TIME|DURATION"
			//LINE   --> "33F43052167D16|2221435146|33F43052167D16|0442221472843|2|04/01/2010|17:21:07|22"

			//In 100_CDRS we have GASSET_TRAFICO_VOZ_20090228.DAT
			//HEADER --> "CELL_START|PHONE1|CELL_FINISH|PHONE2|DIR|TYPE|DATE|TIME|DURATION|CIA_1|CIA_2|UNK_1|UNK_2|OTHER|FACT"
			//LINE   --> "33F43061B65B61|6671573918||018188803536|2|LDN|28/02/2009|03:09:54|3600|118-MOVISTAR|102-BESTPHONE|||354825013513420|RMNACIO"



			//OLM_T(LMT_User01, ("Enters:getCDRFromLine_TEMM_VOZ()"));


			node->value = 0;
			cdr->node.value = 0;

			GET_CDRS_INIT
			//OLM_T(LMT_User01, ("Passed GET_CDRS_INIT"));


			GET_CDRS_NEXT_FIELD
			//Unused field -- START CELL
			//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for START CELL"));

			GET_CDRS_NEXT_FIELD
			//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for PHONE"));
			GET_CDRS_GET_PHONE_MX( node->value )
			//OLM_T(LMT_User01, ("Passed GET_CDRS_GET_PHONE_MX, field:%s, node->value:%ld", line+pos_field, node->value));





			GET_CDRS_NEXT_FIELD
			//Unused field -- FINISH CELL
			//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for FINISH CELL"));

			GET_CDRS_NEXT_FIELD
			//pos_field+=3; // Skip 3 characters of this number
			//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for PHONE"));
			GET_CDRS_GET_PHONE_MX( cdr->node.value )
			//OLM_T(LMT_User01, ("Passed GET_CDRS_GET_PHONE_MX, field:%s, cdr->node:%ld", line+pos_field, cdr->node.value));


			GET_CDRS_NEXT_FIELD
			//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DIR"));
			GET_CDRS_GET_DIR( cdr->dir.value )
			//OLM_T(LMT_User01, ("Passed GET_CDRS_GET_DIR for PHONE"));

			if(cdr->dir.value == 2){
				cdr->dir.value = 0;
			}

			GET_CDRS_NEXT_FIELD
			//Unused field -- CALL TYPE

			GET_CDRS_NEXT_FIELD
			//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DATE"));

			timeExpanded.tm_mday    = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
			timeExpanded.tm_mon   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] ) - 1;
			timeExpanded.tm_year    = 100 + CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );

			GET_CDRS_NEXT_FIELD
			//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for TIME"));

			timeExpanded.tm_hour    = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
			timeExpanded.tm_min  = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
			timeExpanded.tm_sec = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );

			cdr->timeUnix.getTimeUTCFromCalendar(&timeExpanded);
			//cdr->week_day.value = timeExpanded.tm_wday;

			GET_CDRS_NEXT_FIELD
			//OLM_T(LMT_User01, ("Passed GET_CDRS_NEXT_FIELD for DURATION"));
			GET_CDRS_GET_DURATION(cdr->duration.value)

			cdr->type.value = 0;

			//Global Checking...
			if(cdr->node.value <= 999999999)
			{
				//OLM_E(("Error in CDR for cdr->node(%ld) < 999999999", cdr->node.value));
				return false;
			}
			if(node->value <= 999999999)
			{
				//OLM_E(("Error in CDR for node(%ld) < 999999999", node->value));
				return false;
			}
			if(node->value == cdr->node.value)
			{
				//OLM_E(("Error in CDR for (node->value == cdr->node.value)", node->value, cdr->node.value));
				return false;
			}
			if((cdr->dir.value != 1) && (cdr->dir.value != 0))
			{
				//OLM_E(("Error in CDR for ((cdr->dir(%d) != 1) && (cdr->dir != 0))", cdr->dir.value));
				return false;
			}

			return true;
		}
#endif

		bool getCDRFromLine_TEMM_SMS( char *line, samson::system::UInt*node, gstCdr* cdr, int max_digit, int min_digit, bool old )
		{
			//HEADER --> "PHONE1|PHONE2|DIR|Date|Time"
			//LINE --> "6862360363|9371302781|2|01/08/2009|17:52:05"
			//Note: multithread save implementation
			struct tm timeExpanded;

			  unsigned int _pos=0;
			  unsigned int _pos_field=0;

			  try {

			    cdrGetNextField(line, &_pos, &_pos_field);
			    cdrPhoneToNumber(line+_pos_field, &(node->value), max_digit);


			    cdrGetNextField(line, &_pos, &_pos_field);
			    cdrPhoneToNumber(line+_pos_field, &(cdr->phone.value), max_digit);

			    cdrGetNextField(line, &_pos, &_pos_field);
			    GST_get_cdrs_number( line, &(cdr->dir.value), _pos_field );

			    if(cdr->dir.value == 2){
			      cdr->dir.value = 0;
			    }

			    cdrGetNextField(line, &_pos, &_pos_field);
			    cdrStrDateToStructure( line+_pos_field, &timeExpanded, old );

			    cdrGetNextField(line, &_pos, &_pos_field);
			    cdrStrTimeToStructure( line+_pos_field, &timeExpanded );

				cdr->timeUnix.getTimeUTCFromCalendar(&timeExpanded);
				//cdr->week_day.value = timeExpanded.tm_wday;

			    cdr->duration.value = 0;
			    cdr->type.value = 1;

			    cdr->cellId.value = 0;
			    cdr->mobScope.value = 0;

			    //Global Checking...(10 digits)
			    unsigned int min_digit_count_mask = GST_calculate_mask(min_digit);
			    if(cdr->phone.value   <= min_digit_count_mask ) throw false;
			    if(node->value <= min_digit_count_mask ) throw false;
			    if(node->value == cdr->phone.value)      throw false;
			    if((cdr->dir.value != 1) && (cdr->dir.value != 0))   throw false;

			  }catch( ... ){
				  OLM_D(("Line rejected: '%s'\n", line));
			    return false;
			  }

			return true;
		}

		bool getCDRFromLine_TEMM_MMS( char *line, samson::system::UInt*node, gstCdr* cdr, int max_digit, int min_digit, bool old )
		{
			//HEADER --> "PHONE1|PHONE2|DIR|Date|Time"
			//LINE   --> "525523749235|5541871842|1|01/08/2009|00:30:02"
			//Note: multihtread save implementation
			  //HEADER --> "PHONE1|PHONE2|DIR|Date|Time"
			  //LINE   --> "525523749235|5541871842|1|01/08/2009|00:30:02"
			  //Note: multithread save implementation
			struct tm timeExpanded;

			  unsigned int _pos=0;
			  unsigned int _pos_field=0;

			  try{

			    cdrGetNextField(line, &_pos, &_pos_field);
			    cdrPhoneToNumber(line+_pos_field, &(node->value), max_digit);

			    cdrGetNextField(line, &_pos, &_pos_field);
			    cdrPhoneToNumber(line+_pos_field, &(cdr->phone.value), max_digit);

			    cdrGetNextField(line, &_pos, &_pos_field);
			    GST_get_cdrs_number( line, &(cdr->dir.value), _pos_field );

			    if(cdr->dir.value == 2){
			      cdr->dir.value = 0;
			    }

			    cdrGetNextField(line, &_pos, &_pos_field);
			    cdrStrDateToStructure( line+_pos_field, &timeExpanded, old );

			    cdrGetNextField(line, &_pos, &_pos_field);
			    cdrStrTimeToStructure( line+_pos_field, &timeExpanded );

				cdr->timeUnix.getTimeUTCFromCalendar(&timeExpanded);
				//cdr->week_day.value = timeExpanded.tm_wday;

			    cdr->duration.value = 0;
			    cdr->type.value = 2;

			    cdr->cellId.value = 0;
			    cdr->mobScope.value = 0;

			    //Global Checking...
			    unsigned int min_digit_count_mask = GST_calculate_mask(min_digit);
			    if(cdr->phone.value <= min_digit_count_mask)   throw false;
			    if(node->value <= min_digit_count_mask) throw false;
			    if(node->value == cdr->phone.value)            throw false;
			    if((cdr->dir.value != 1) && (cdr->dir.value != 0))  throw false;

			  }catch( ... ){
				  OLM_D(("Line rejected: '%s'\n", line));
			    return false;
			  }

			return true;
		}

#if 0

		bool getCDRFromLine_MX( char *line, samson::system::UInt*node, CDR* cdr, int max_digit, int min_digit, bool old )
		{
			//LINE   --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
			//Note: multihtread save implementation

			GET_CDRS_INIT

			GET_CDRS_NEXT_FIELD     //Unused field

			GET_CDRS_NEXT_FIELD
			GET_CDRS_GET_NUMBER( node->value )

			GET_CDRS_NEXT_FIELD     //Unused field

			GET_CDRS_NEXT_FIELD
			pos_field+=3; // Skip 3 characters of this number
			GET_CDRS_GET_NUMBER( cdr->node.value )

			GET_CDRS_NEXT_FIELD     //Unused field

			GET_CDRS_NEXT_FIELD

			timeExpanded.tm_mday     = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
			timeExpanded.tm_mon   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] ) - 1;
			timeExpanded.tm_year    = 100 + CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );

			GET_CDRS_NEXT_FIELD     //Unused field

			timeExpanded.tm_hour    = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
			timeExpanded.tm_min  = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
			timeExpanded.tm_sec = CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );

			cdr->timeUnix.getTimeUTCFromCalendar(&timeExpanded);
			//cdr->week_day.value = timeExpanded.tm_wday;

			GET_CDRS_NEXT_FIELD
			GET_CDRS_GET_DURATION(cdr->duration)


			//Global Checking...
			if(cdr->node.value <= 0)        return false;
			if(node->value <= 0)      return false;
			if(node->value == cdr->node.value)  return false;

			return true;
		}


		bool getCDRFromLine_JAJAH( char *line, samson::system::UInt*node, CDR* cdr, int max_digit, int min_digit, bool old )
		{
			//HEADER --> "CALL ID|MemberA_ID|MemberA_Phone|MemberB_Phone|Date&Time|Duration|Type"
			//LINE --> "173731833|182385|390817917344|393333303646|2010-01-01 00:00:00|0|SMS\n"
			//Note: multihtread save implementation

			//This function in the Jajah format yields an output that doesn't contain the member ID of the MemberB, only the phone number.
			//Thus, an additional step is necessary after this parsing. For that purpose, the key of this dataset will be the MemberB Phone number
			//instead of the MemberA userID. thanks to this, the set can be combined with a [UserPhone - User] Data set in a Reduce operation
			//to replace the MemberB Phone for the MemberB userID, if exists.

			GET_CDRS_INIT

			GET_CDRS_NEXT_FIELD
			//First field useless

			GET_CDRS_NEXT_FIELD //MemberA ID
			GET_CDRS_GET_NUMBER( cdr->node.value )

			GET_CDRS_NEXT_FIELD
			//MemberA_Phone not used by the moment. Jajah recognizes users by memberID

			GET_CDRS_NEXT_FIELD //MemberB Phone
			GET_CDRS_GET_NUMBER( node->value )


			GET_CDRS_NEXT_FIELD //Date and time

			timeExpanded.tm_year    = 100 + CHAR_TO_INT( line[pos_field+2] ) *10 + CHAR_TO_INT( line[pos_field+3] );
			timeExpanded.tm_mon   = CHAR_TO_INT( line[pos_field+5] ) *10 + CHAR_TO_INT( line[pos_field+6] ) - 1;
			timeExpanded.tm_mday   = CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );


			timeExpanded.tm_hour    = CHAR_TO_INT( line[pos_field+11] ) *10 + CHAR_TO_INT( line[pos_field+12] );
			timeExpanded.tm_min  = CHAR_TO_INT( line[pos_field+14] ) *10 + CHAR_TO_INT( line[pos_field+15] );
			timeExpanded.tm_sec = CHAR_TO_INT( line[pos_field+17] ) *10 + CHAR_TO_INT( line[pos_field+18] );

			cdr->timeUnix.getTimeUTCFromCalendar(&timeExpanded);
			//cdr->week_day.value = timeExpanded.tm_wday;


			GET_CDRS_NEXT_FIELD //Duration
			GET_CDRS_GET_DURATION(cdr->duration)


			//Global Checking...
			if(cdr->node.value <= 0)        return false;
			if(node->value <= 0)      return false;
			if(node->value == cdr->node.value)  return false;

			return true;
		}

		bool getCDRFromLine_TASA( char *line, samson::system::UInt*node, CDR* cdr, int max_digit, int min_digit, bool old )
		{
			//LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
			//Note: multihtread save implementation

			GET_CDRS_INIT

			GET_CDRS_NEXT_FIELD
			GET_CDRS_GET_NUMBER( node->value )

			GET_CDRS_NEXT_FIELD
			GET_CDRS_GET_NUMBER( cdr->node.value )


			GET_CDRS_NEXT_FIELD

			// Assuming years after 2000
			timeExpanded.tm_mday   = CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
			timeExpanded.tm_mon   = CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] ) - 1;
			timeExpanded.tm_year    = 100 + CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );

			timeExpanded.tm_hour    = 0 ;
			timeExpanded.tm_min  = 0 ;
			timeExpanded.tm_sec = 0 ;

			cdr->timeUnix.getTimeUTCFromCalendar(&timeExpanded);
			//cdr->week_day.value = timeExpanded.tm_wday;


			GET_CDRS_NEXT_FIELD
			GET_CDRS_GET_DURATION(cdr->duration)

			cdr->dir.value    = 1 ;

			//Global Checking...
			if(cdr->node.value <= 0)        return false;
			if(node->value <= 0)      return false;
			if(node->value == cdr->node.value)  return false;

			return true;
		}

#endif


		void init( samson::KVWriter *writer )
		{
			min_digit = environment->getInt(GST_PARAMETER_MIN_PHONE_DIGITS, GST_PARAMETER_MIN_PHONE_DIGITS_DEFAULT);
			max_digit = environment->getInt(GST_PARAMETER_MAX_PHONE_DIGITS, GST_PARAMETER_MAX_PHONE_DIGITS_DEFAULT);
			old_date = environment->getInt(GST_FLAG_OLD_DATE, GST_FLAG_OLD_DATE_DEFAULT);

			std::string format = environment->get( GST_PARAMETER_CDR_FORMAT, GST_PARAMETER_CDR_FORMAT_DEFAULT);


			if( format.compare("TEMM_VOZ")==0 )
				_getCDRFunction = &parse_gst_cdrs::getCDRFromLine_TEMM_VOZ;
			else if( format.compare("TEMM_SMS")==0 )
				_getCDRFunction = &parse_gst_cdrs::getCDRFromLine_TEMM_SMS;
			else if( format.compare("TEMM_MMS")==0 )
				_getCDRFunction = &parse_gst_cdrs::getCDRFromLine_TEMM_MMS;
#if 0
			else if( format.compare("TME")==0 )
				_getCDRFunction = &parse_cdrs::getCDRFromLine_TME;
			else if( format.compare("JAJAH")==0 )
				_getCDRFunction = &parse_cdrs::getCDRFromLine_JAJAH;
			else if( format.compare("MX")==0 )
				_getCDRFunction = &parse_cdrs::getCDRFromLine_MX;
			else if( format.compare("TASA")==0 )
				_getCDRFunction = &parse_cdrs::getCDRFromLine_TASA;
#endif
			else {
				OLM_E(("Error. Format not supported\n"));
				exit(1);;
			}

		}


		void parseLines( char *line, samson::KVWriter *writer )
		{
			//Datas to emit
			samson::system::UInt number;
			gstCdr cdr;

			if( (this->*_getCDRFunction)(line , &number , &cdr, max_digit, min_digit, old_date))
			{

#define MAX_STR_LEN 1024
				//char output[MAX_STR_LEN];
				//ctime_r(&(cdr.timeUnix.value), output);
				//output[strlen(output)-1] = '\0';
				//OLM_T(LMT_User06, ("cdr: time: '%s', week_day: %d\n", output, int(cdr.week_day.value)));

				writer->emit(0, &number, &cdr);

			}
			else
			{
				//OLM_E(("Error parsing line:'%s' for CDR", line));
				;
			}
		}


		void run( char *data , size_t length , samson::KVWriter *writer )
		{
			size_t offset = 0;
			size_t line_begin = 0;

			while( offset < length )
			{

				if( data[offset] == '\n')
				{
					data[offset] = '\0';

					parseLines(data+line_begin , writer);

					line_begin = offset+1;
				}
				++offset;
			}
		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace samson
} // end of namespace cdr

#endif
