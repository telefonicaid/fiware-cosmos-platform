Module snalight
{

	title	"Social Network Analysis from graphs"
	author 	"Andreu Urruela (andreu@tid.es)"
	version "2.4.0"

	set	 snalight.num_cdrs_for_strong_connection		4
	set	 snalight.history_graph_importance				0.7
	set	 snalight.weight_link_to_die				85
	set	 snalight.number_spikes_to_punctual_relationship	1
	set	 snalight.threshold_to_fuse_cliques			 0.7
	set	 snalight.threshold_to_add_associated_nodes		 0.6
	set	 snalight.cliques_penalization_missing_link		 1.0
	set	 snalight.max_strong_connections_per_node			 50
	set	 snalight.max_connections_per_node				400
	set	 snalight.community_fusion_min_overlaping			 0.8
	set	 snalight.community_fusion_new_threshold		0.5
	set	 snalight.community_max_community_links		 10
	set	 snalight.min_weighted_link_weight				150
	help
	{
	"snalight Module"
	"----------------------------------------------"
	"Auth: Andreu Urruela"
	""
	"snalight Module is a set of elements for the MACRO platform designed to work with CDRs"
	""
	"** Basic data types:\n"
	"Link:				node-weight,dir (information about a particular link between nodes)"
	"Node:				Node in a graph (nodeId + list of links)"
	"Clique:			Vector of identifiers of nodes"
	"Vector_Node:			 A vector of node. It can be considered as a clique/community"
	""
	"** CDRs **"
	""
	"snalight.fake_cdrs:		 Generate a fake set of cdrs"
	"snalight.cdrs:				Parser to get CDRs from txt-files"
	"snalight.spread_cdrs:			 Spread the CDRs into connections links"
	""
	"** GRAPH **"
	""
	"snalight.get_graph:		 Compute a graph from a set of bidirectional links"
	"snalight.cross_graph_users:	 Combine a graph with a set with information about users (external flag)"
	"snalight.filter_graph_map:		First step to filter a graph ( max stong connections ) "
	"snalight.filter_graph_reduce:		 Second step to filter a graph"
	"snalight.select_nodes_from_graph:	 Tool to select some nodes from a graph (usefull for debuging)"
	"snalight.combine_graphs:		Tool used to fuse several graphs (i.e. a graph per month)"
	"-"
	"snalight.linksp:			Parser to get a set of bidirectional links with weight"
	"snalight.combine_links:		 Alternative way to create a graph from a set of birirectional links and weights"
	""
	"** CLIQUES **"
	""
	"snalight.spread_nodes:			First step computing cliques from a graph"
	"snalight.combine_nodes:		 Second step computing cliques from a graph"
	"-"
	"snalight.cliques:			 Parser to get cliques from a per-line file"
	"snalight.collapse_cliques:		Build the cliques-set from a per-line definition of cliques"
	""
	""
	"** MAIN SCRIPTS **"
	""
	"snalight.full_process graph cliques communities1 communities2 communities3:"
	"			 Full process from graph to cliques & communities (level1,2,3)"
	"-"
	"snalight.compute_cliques graph cliques:	 Compute cliques from	graph"
	"snalight.fuse_communities:		Process of combine internally cliques to obtain communities"
	"snalight.add_associated_nodes:		Add associated nodes to communities"

	}


}

# ---------------------------------------------------------------------------
# datas for snalight
# ---------------------------------------------------------------------------

# Link: Connection between two telephone numbers

data Link
{
	 system.UInt id;
	 system.Float weight;
	 system.Float dir;
}

# Node: Main element in the snalight process

data Node
{
	 system.UInt id;
	 vector snalight.Link links;
	 system.Int8 flags;
}


data Clique
{
	 vector system.UInt nodes;
}

data Clique_Link
{
	 snalight.Clique clique;
	 system.Float weight;	
}


data Clique_Node
{
	 snalight.Clique clique;
	 vector snalight.Clique_Link links;
}

data Vector_Clique_Node
{ 
	 vector snalight.Clique_Node items;
}

data Clique2
{
	 snalight.Clique clique_1;
	 snalight.Clique clique_2;
}

# Vectors of nodes and cliques

data Vector_Node
{
	vector snalight.Node items;
}



data Vector_Clique 
{ 
	vector snalight.Clique items; 
}

#CDRs

data CDR
{
	 system.UInt node;
	 system.UInt duration;
	 system.UInt type;	# 0=voice; 1=sms; 2=mms;
	 system.UInt dir;
}

# User information

data User
{
	 system.UInt id;
	 system.UInt titularId;
	 system.UInt8 type;
	 system.Date activationDate;
	 system.UInt8 activationCode;
	 system.UInt8 age;
	 system.UInt8 province;
	 system.UInt8 sex;
	 system.Date churnDate;
	 system.UInt8 churnCode;
}


#MASP
data Link_Edges
{
	system.UInt phoneA;
	system.UInt phoneB;
}

# MASP Communities
data Community
{
	system.UInt id_comm;
	snalight.Clique nodes;
	snalight.Clique orphan;
}

# MASP Metric: datas of Node metric
data Metric_Node_complete
{
	 system.UInt id;
	 system.UInt links_count;
	 system.UInt strong_links_count;
	 system.UInt strong_links_sum;
	 system.UInt weak_links_count;
	 system.UInt weak_links_sum;

	 system.UInt strong_links_comp_count;
	 system.UInt weak_links_comp_count;

	 system.UInt count_comm;
	 system.UInt count_comm_as_strong;
	 system.UInt count_comm_as_weak;
	 system.UInt average_size_comm;
	 system.UInt average_size_comm_regular;
	 system.UInt average_size_comm_orphan;

	 system.UInt reach_two_step;
	 system.UInt reach_two_step_competitors;

	 system.UInt coef_cluster;
}

# MASP Metric: datas of Node metric
data Metric
{
	 system.UInt id;
	 system.UInt links_count;
	 system.UInt strong_links_count; #weight >=1
	 system.UInt strong_links_sum;
	 system.UInt weak_links_count; #weight <1
	 system.UInt weak_links_sum;

	 system.UInt strong_links_comp_count;
	 system.UInt weak_links_comp_count;

#	 system.UInt strong_links_comp_sum;
#	 system.UInt weak_links_comp_sum;
#	 system.UInt strong_links_tef_sum;
#	 system.UInt weak_links_tef_sum;
}

# MASP Metric: datas of Reached Nodes metric
data Metric_Reach
{
	 system.UInt reach_two_step;
	 system.UInt reach_two_step_competitors; #COMPETITORS
	 system.UInt reach_two_step_tef;	 #TELEFONICA

}


# MASP Metric: datas of Reached Nodes for Communities metric
data Metric_Reach_Comm
{
	 system.UInt reach_one_step;
	 system.UInt reach_one_step_competitors;
	 system.UInt reach_comm_on_step;
}

# MASP Metric: data intermediate of Reached Nodes for Communities metric
data Metric_Reach_Comm_intemediate
{
	 snalight.Clique comm;
	 snalight.Clique reach_nodes;
	 snalight.Clique reach_nodes_competitors;
}

# MASP Metric: datas of cluster coefficent metric
data Metric_Cluster
{
	 system.UInt	 node_id;
	 system.UInt	 cluster_coef;

}

# MASP Metric: datas of cluster coefficent metric
data Metric_Cluster_Intermediate
{
	 system.UInt node_id;
	 snalight.Clique comm_id;
	 system.UInt count_links;
	 system.UInt density;
}
# MASP Metric: datas of Communities metric
data Metric_Communities
{
	 system.UInt id_comm;

	 system.UInt count_nodes;

	 system.UInt count_nodes_strong;
	 system.UInt count_nodes_associated;
	 system.UInt count_nodes_competitor;
	 system.UInt count_nodes_telefonica;

	 system.UInt percent_nodes_competitor;
	 system.UInt percent_nodes_strong;
	 system.UInt percent_nodes_associated;
	 system.UInt percent_nodes_telefonica;

	 system.UInt count_regular_existing_links;
	 system.UInt count_regular_possible_links;
	 system.UInt count_all_existing_links;
	 system.UInt count_all_possible_links;

	 system.UInt density_regular_members;
	 system.UInt density_all_members;

	 system.UInt cohesion_regular_members;
	 system.UInt cohesion_all_members;

	 system.UInt value_total;
	 system.UInt value_per_node;
	 system.UInt value_per_edge;

	 system.UInt reach_one_step;
	 system.UInt reach_one_step_competitors;
	 system.UInt reach_comm_on_step;

}

# MASP Metric: datas of Nodes belongs Communities metric
data Metric_Node_Communities
{
	 system.UInt node_id;
	 system.UInt count_comm;
	 system.UInt count_comm_as_strong;
	 system.UInt count_comm_as_weak;
	 system.UInt average_size_comm;
	 system.UInt average_size_comm_regular;
	 system.UInt average_size_comm_orphan;

}

# MASP Metric: Reached Nodes with flags
data Node_Reach
{
	 system.UInt node_id;
	 system.UInt node_reached;
	 system.UInt weight;
	 system.Int8 flags;
}

# MASP Metric: Reached Nodes with Weight
data Node_Comm_Weight
{
	 system.UInt node_id;
	 system.UInt count_links;
	 system.UInt count_extern_links;
	 system.UInt weight_all_members;
	 system.UInt weight_extern_members;
	 system.UInt count_comm_extern_nodes;
	 system.UInt count_competitor_nodes;
}

# MASP Metric: Join of Communitiies and nodes
data Node_Communities
{
	 snalight.Clique comm_id;
	 system.UInt node_id;
	 snalight.Clique orphan;
}

# MASP Metric: datas intermediate of Nodes in Communities metric
data Metric_Node_In_Comm_Intermediate
{
	 system.UInt	 node_id;
	 snalight.Clique comm_id;
	 system.UInt	 sum_weights_node;
	 system.UInt	 count_links_node;
}

# MASP Metric: datas of Nodes in Communities metric
data Metric_Node_In_Comm
{
	 snalight.Clique comm;
	 snalight.Clique orphan;
	 system.UInt id_comm;
	 system.UInt node_id;
	 system.UInt absolute_weights;
	 system.UInt realtive_weights;
	 system.UInt absolute_neighbours;
	 system.UInt relative_neighbours;
}


#Temporal Weighting
data TimeSeries
{
	system.UInt linkedId;
	vector system.UInt weights;
}





# Computing cliques from a graph

script compute_cliques
{
	in	system.UInt snalight.Node
	out	snalight.Clique system.Void
	
	top

	code
	{
		snalight.spread_nodes_to_strong_connections $1 $1.spread -create -clear;
		snalight.compute_cliques_from_spread_graph $1.spread $2 -clear;
		#rm $1.spread -f;
	}

	helpLine "Compute cliques from a graph"		
}

map spread_nodes_to_strong_connections
{
	in system.UInt	snalight.Node
	out system.UInt	snalight.Node

	helpLine	"First step to compute cliques from a graph."
	
	help
	{
		"First step to compute cliques from a graph."
		"Here, nodes are spread in the sense that for each input node in the graph, we emit N outputs where"
		"N is the number of strong connections"
		"Basically, we sent the node to all the strongly connected nodes"
		"For performance, a reduced version of the node (only strong connections) is sent"
	}
}

reduce compute_cliques_from_spread_graph
{
	in	system.UInt snalight.Node
	out	snalight.Clique system.Void
	
	helpLine	"Second step of the compute_cliques script"

	help
	{
		"Second step to compute cliques from a graph."
		"Here, we collect all the nodes that are connected to a particular node, and the cliques are computed"
	}
}

parserOut export_cliques
{
	in snalight.Clique system.Void

	helpLine "Export cliques to txt files"
}

script graph_to_communities
{
	in system.UInt snalight.Node # (1) graph
	out snalight.Clique snalight.Community # (2) final communities
	out txt txt # (3) final communities txt

	help
	{
		"Full process from a graph to final communities"
	}

	code
	{
		rm $1_cliques -f;
		rm $1_cliques_graph -f;

		rm $1_com1 -f;
		rm $1_com1_graph -f;
		rm $1_com2 -f;
		rm $1_com3 -f;

		rm $1_dyads -f;
		rm $1_com3_dyads -f;

		snalight.compute_cliques $1 $1_cliques -create -clear;

		snalight.get_cliques_graph $1_cliques $1 $1_cliques_graph -create -clear;
		snalight.compute_cliques_of_cliques $1_cliques_graph $1_com1 -create -clear;

		snalight.get_communities_graph $1_com1 $1 $1_com1_graph -create -clear;
		snalight.compute_cliques_of_cliques $1_com1_graph $1_com2 -create -clear;

		snalight.add_associated_nodes $1_com2 $1 $1_com3 -create -clear;

		snalight.calculate_dyads $1_com3 $1 $1_dyads -create -clear;
		snalight.merge_dyads_into_communities $1_dyads $1_com3 $1_com3_dyads -create -clear;

		snalight.generate_comm_unique_id $1_com3_dyads $2 -create -clear;
		snalight.communities_unique_id_out $2 $3 -create -clear;

		rm $1_cliques -f;
		rm $1_cliques_graph -f;
		rm $1_com1 -f;
		rm $1_com1_graph -f;
		rm $1_com2 -f;
		rm $1_com3 -f;
		rm $1_dyads -f;
		rm $1_com3_dyads -f;
	}
}


script parse_graph
{
	in txt txt
	out system.UInt snalight.Node

	top

	help
	{
	"Transform a txt-based file with a graph into a macro-binary graph with key-value [UInt Node]"
	"The input graph is suppoused to be a list of connections between nodes"
	"A B for each line where A < B"
	}

	code
	{
	rm $1_link -f;
	snalight.parse_links $1 $1_links -create -clear;		# Parse links emiting two outputs per line
	snalight.get_graph_from_links2 $1_links $2 -create -clear; # collapse all links into a graph
	rm $1_link -f;
	}

}

script mx_calls_cdrs_to_graph
{
	in txt txt
	out system.UInt snalight.Node

	help
	{
	"Transform a set of CDRs to a unitary graph with key-value [UInt Node]"
	"Use acg_mex_calls_cdrs_to_graph input output"
	}

	code
	{
	rm $1_cdrs_bin -f;
	rm $1_cdrs_bin_ini -f;
	rm $1_cdrs_bin_dup -f;
	rm $1_cdrs_bin_fin -f;
	rm $2_pre -f;
	rm $2_wkill -f;
	rm $2_sinks_txt -f;

	set sna.cdr_format TEMM_VOZ;
	set sna.num_cdrs_for_strong_connection 2;
	set sna.max_connections_per_node 8;
	set sna.max_strong_connections_per_node 6;

	snalight.parse_cdrs $1 $1_cdrs_bin_ini -clear -create;
	snalight.acg_map_dup_cdrs $1_cdrs_bin_ini $1_cdrs_bin_dup -clear -create;
	snalight.remove_duplicates $1_cdrs_bin_dup $1_cdrs_bin_fin -clear -create;
	snalight.acg_red_cdrs_to_nodes $1_cdrs_bin_fin $2_pre -clear -create;
	snalight.filter_graph_map $2_pre $2_wkill -clear -create;
	snalight.filter_graph_reduce $2_wkill $2 -clear -create;
	rm $1_cdrs_bin -f;
	rm $1_cdrs_bin_ini -f;
	rm $1_cdrs_bin_dup -f;
	rm $1_cdrs_bin_fin -f;
	rm $2_pre -f;
	rm $2_wkill -f;
	}

}

script mx_sms_cdrs_to_graph
{
	in txt txt
	out system.UInt snalight.Node

	top

	help
	{
	"Transform a set of CDRs to a unitary graph with key-value [UInt Node]"
	"Use acg_mex_calls_cdrs_to_graph input output"
	}

	code
	{
	rm $1_cdrs_bin -f;
	rm $1_cdrs_bin_ini -f;
	rm $1_cdrs_bin_dup -f;
	rm $1_cdrs_bin_fin -f;

	rm $2_pre -f;
	rm $2_wkill -f;
	rm $2_sinks_txt -f;

	snalight.parse_cdrs $1 $1_cdrs_bin_ini -format TEMM_SMS;
	acg_map_dup_cdrs $1_cdrs_bin_ini $1_cdrs_bin_dup;
	remove_duplicates $1_cdrs_bin_dup $1_cdrs_bin_fin;
	acg_red_cdrs_to_nodes $1_cdrs_bin_fin $2_pre;

	snalight.filter_graph_map $2_pre $2_wkill;
	snalight.filter_graph_reduce $2_wkill $2;


	snalight.social_graph_parse_out_sinks $2_pre $2_sinks_txt;

	rm $1_cdrs_bin -f;
	rm $1_cdrs_bin_ini -f;
	rm $1_cdrs_bin_dup -f;
	rm $1_cdrs_bin_fin -f;

	rm $2_pre -f;
	rm $2_wkill -f;
	}

}

script mx_mms_cdrs_to_graph
{
	in txt txt
	out system.UInt snalight.Node

	top

	help
	{
	"Transform a set of CDRs to a unitary graph with key-value [UInt Node]"
	"Use acg_mex_calls_cdrs_to_graph input output"
	}

	code
	{
	rm $1_cdrs_bin -f;
	rm $1_cdrs_bin_ini -f;
	rm $1_cdrs_bin_dup -f;
	rm $1_cdrs_bin_fin -f;
	rm $2_pre -f;
	rm $2_wkill -f;
	rm $2_sinks_txt -f;

	snalight.parse_cdrs $1 $1_cdrs_bin_ini -format TEMM_MMS;
	acg_map_dup_cdrs $1_cdrs_bin_ini $1_cdrs_bin_dup;
	remove_duplicates $1_cdrs_bin_dup $1_cdrs_bin_fin;
	acg_red_cdrs_to_nodes $1_cdrs_bin_fin $2_pre;

	snalight.filter_graph_map $2_pre $2_wkill;
	snalight.filter_graph_reduce $2_wkill $2;

	snalight.social_graph_parse_out_sinks $2_pre $2_sinks_txt;

	rm $1_cdrs_bin -f;
	rm $1_cdrs_bin_ini -f;
	rm $1_cdrs_bin_dup -f;
	rm $1_cdrs_bin_fin -f;

	rm $2_pre -f;
	rm $2_wkill -f;
	}

}


script parse_cliques
{
	in	txt txt
	out snalight.Cliques system.Void

	top

	help
	{
	"Transform a txt-based file with cliques into a macro-binary set of cliques"
	"The input is suppoused to be a list of all the nodes that belongs to each clique in this format"
	"cliqueId nodeID"
	"No order is assumed at the input"
	}

	code
	{
	rm $1_binary -f;			 # Remove temporal files used in this process
	snalight.parse_cliques_as_cliques_groups $1 $1_binary;	# Parse txt file
	snalight.get_cliques_from_cliques_groups $1_binary $2;	# collapse all the cliques into a Clique-Void set
	rm $1_binary -f;
	}

}

script parse_cliques2
{
	in	txt txt
	out snalight.Cliques system.UInt

	top

	help
	{
	"Transform a txt-based file with cliques into a macro-binary set of cliques"
	"The input is suppoused to be a list of all the nodes that belongs to each clique in this format"
	"cliqueId nodeID"
	"No order is assumed at the input"
	}

	code
	{
	rm $1_binary -f;			 # Remove temporal files used in this process
	snalight.parse_cliques_as_cliques_groups $1 $1_binary;	# Parse txt file
	snalight.get_cliques_from_cliques_groups2 $1_binary $2;	 # collapse all the cliques into a Clique-Void set
	rm $1_binary -f;
	}

}


script filter_graph
{
	in	system.UInt snalight.Node
	out system.UInt snalight.Node

	help
	{
	"Filter graph to remove elements with too much connections"
	"Internal variables snalight.max_connections_per_node & snalight.max_strong_connections_per_node controls"
	"the maximum number of connections and the maximum number of strong connections respectivelly"
	}

	code
	{
	rm $1_spread -f;	 # Remove tmp files
	snalight.filter_graph_map $1 $1_spread;
	snalight.filter_graph_reduce $1_spread $2;
	rm $1_spread -f;
	}
}




# --------------------------------------------
# Fuse cliques or communities
# --------------------------------------------


script get_cliques_graph
{
	in snalight.Clique system.Void	# Cliques
	in system.UInt snalight.Node	# Graph
	out snalight.Clique snalight.Clique_Node	# Graph of cliques

	help
	{
	"Compute all possible links between cliques computing all possible pairs of cliques and joining with graph"
	}

	top

	code
	{
	rm $1_spread_per_node -f;
	rm $1_links_previous -f;
	rm $1_links_previous_nodes -f;
	rm $1_links -f;
	rm $1_links_to_be_removed -f;
	rm $1_links_ready -f;

	snalight.spread_cliques_per_node $1 $1_spread_per_node;				 # Spread cliques to all components (nodeIds)
	snalight.get_possible_cliques_links $1_spread_per_node $1_links_previous;			 # Create all possible links (sharing at least one node)
	snalight.get_clique_links_with_nodes $1_links_previous $2 $1_links_previous_nodes;		# Combine with the graph to spread necessary information

	snalight.get_clique_links $1_links_previous_nodes $1_links;				 # Eval the links to see if they are real

	snalight.select_clique_links_to_be_removed $1_links $1_links_to_be_removed;		 # Remove links between cliques (rank 10)
	remove_full $1_links $1_links_to_be_removed $1_links_ready;

	snalight.compute_cliques_graph $1 $1_links_ready $3;				# Get graph of cliques

	rm $1_spread_per_node -f;
	rm $1_links_previous -f;
	rm $1_links_previous_nodes -f;
	rm $1_links -f;
	rm $1_links_to_be_removed -f;
	rm $1_links_ready -f;
	}
}

script get_communities_graph
{
	in snalight.Clique system.Void	# Cliques
	in system.UInt snalight.Node	# Graph
	out snalight.Clique snalight.Clique_Node	# Graph of cliques

	help
	{
	"Compute all possible links between cliques computing all possible pairs of cliques and joining with graph"
	}

	top

	code
	{
	rm $1_spread_per_node -f;
	rm $1_links_previous -f;
	rm $1_links_previous_nodes -f;
	rm $1_links -f;
	rm $1_links_to_be_removed -f;
	rm $1_links_ready -f;

	snalight.spread_cliques_per_node $1 $1_spread_per_node;				 # Spread cliques to all components (nodeIds)
	snalight.get_possible_cliques_links $1_spread_per_node $1_links_previous -communities;	# Create all possible links (sharing at least one node)
	snalight.get_clique_links_with_nodes $1_links_previous $2 $1_links_previous_nodes;		# Combine with the graph to spread necessary information

	snalight.get_clique_links $1_links_previous_nodes $1_links -communities;		# Eval the links to see if they are strong enougth

	snalight.select_clique_links_to_be_removed $1_links $1_links_to_be_removed;		 # Remove links between cliques (rank 10)
	remove_full $1_links $1_links_to_be_removed $1_links_ready;

	snalight.compute_cliques_graph $1 $1_links_ready $3;				# Get graph of cliques

	rm $1_spread_per_node -f;
	rm $1_links_previous -f;
	rm $1_links_previous_nodes -f;
	rm $1_links -f;
	rm $1_links_to_be_removed -f;
	rm $1_links_ready -f;
	}


}

script compute_cliques_of_cliques
{
	in	snalight.Clique snalight.Clique_Node	# Graph of cliques
	out snalight.Clique system.Void		 # New set of cliques

	top

	help
	{
	"Compute the new set of cliques from the original cliques and the links between cliques"
	}


	code
	{
	rm $1_spread -f;
	rm $2_previous_full_communities -f;
	rm $2_previous -f;
	rm $2_previous_spread -f;
	rm $2_to_be_removed -f;

	snalight.spread_cliques_graph	$1 $1_spread;					# Compute communities
	snalight.compute_new_cliques $1_spread $2_previous_full_communities;

	snalight.select_key_in_cliques_graph $2_previous_full_communities $2_previous;		# Select the key.. the communities
	snalight.spread_cliques_per_node $2_previous $2_previous_spread;			# Compute the communities that should be removed
	snalight.get_unnecessary_cliques	$2_previous_spread $2_to_be_removed;		# Compute the communities that should be removed
	snalight.remove_cliques $2_previous $2_to_be_removed $2;			# Remove the communities that should be removed

	rm $1_spread -f;
	rm $2_previous_full_communities -f;
	rm $2_previous -f;
	rm $2_previous_spread -f;
	rm $2_to_be_removed -f;
	}

}

script remove_unnecessary_cliques
{

	#in snalight.Clique	system.Void
	#out snalight.Clique system.Void
	in	snalight.Clique	snalight.Clique
	out snalight.Clique	snalight.Clique

	code
	{
	rm $1_void -f;
	rm $1_spread -f;
	rm $1_to_be_removed -f;
	remove_values $1 $1_void;		# Compute the communities that should be removed
	snalight.spread_cliques_per_node $1_void $1_spread;			 # Compute the communities that should be removed
	snalight.get_unnecessary_cliques	$1_spread $1_to_be_removed;		 # Compute the communities that should be removed
	snalight.remove_cliques_with_associated $1 $1_to_be_removed $2;			 # Remove the communities that should be removed
	rm $1_void -f;
	rm $1_spread -f;
	rm $1_to_be_removed -f;
	}

	help
	{
	"Remove unnecessary cliques/communities".
	"Concretelly, it removes cliques included in other cliques or duplicated cliques"
	}

}

script calculate_dyads
{
	in snalight.Clique snalight.Clique	#Comunidades
	in system.UInt snalight.Node	#Grafo
	out system.UInt graph.Link	 #Dyads

	code
	{
	snalight.spread_communities_to_links $1 $1_spread_links;
	snalight.get_dyads $2 $1_spread_links $3;
	rm $1_spread_links;
	}

	help
	{
	"Extracts the dyads given a Graph file and its Communities file."
	"Usage: calculate_dyads [communities] [graph] [dyadsFileName]"
	}
}



script extract_dyads
{
	in snalight.Clique snalight.Clique	#Comunidades
	in system.UInt snalight.Node	#Grafo
	out txt txt	 #Dyads

	code
	{
	rm $1_spread_links -f;
	rm $1_dyads -f;

	snalight.spread_communities_to_links $1 $1_spread_links;
	snalight.get_dyads $2 $1_spread_links $1_dyads;
	snalight.parse_out_dyads $1_dyads $3;

	rm $1_spread_links -f;
	rm $1_dyads -f;
	}

	help
	{
	"Extracts the dyads given a Graph file and its Communities file."
	"the ouput format of the dyads is in the form UInt Link (MemberA_ID - MemberB_ID Weight)."
	"Usage: extract_dyads [communities] [graph] [dyadsFileName]"
	}
}


parserOut parse_out_dyads
{
	in	system.UInt snalight.Link

	setup

	help
	{
	"Print a set of dyads (no information on weight or dir is printed)"
	}
}

script merge_dyads_into_communities
{
	in	system.UInt graph.Link		#$1 - dyads
	in	snalight.Clique snalight.Clique	#$2 - comms
	out snalight.Clique snalight.Clique	#$3 - comm & dyads

	code
	{
	rm $1_comm_format -f;

	snalight.convert_dyads_to_comm $1 $1_comm_format;
	snalight.merge_dyads_into_communities_red $2 $1_comm_format $3;

	rm $1_comm_format -f;
	}

	help
	{
	"Merge dyads into comm"
	}
}

map convert_dyads_to_comm
{
	in	system.UInt graph.Link
	out snalight.Clique snalight.Clique


	help
	{
	"Change the format of dyads from [UInt Link] to [Clique Clique]"
	}
}

reduce merge_dyads_into_communities_red
{
	in	snalight.Clique snalight.Clique	#$1 - dyads
	in	snalight.Clique snalight.Clique	#$2 - comms
	out snalight.Clique snalight.Clique


	help
	{
	"Merge dyads into comm"
	}
}


# --------------------------------------------
# Fuse cliques or communities
# --------------------------------------------


script add_associated_nodes
{
	in	snalight.Clique system.Void
	in	system.UInt snalight.Node
	out snalight.Clique snalight.Clique

	top

	code
	{
	rm $1_with_nodes -f;
	#rm $3b -f;

	snalight.cross_cliques_with_nodes $1 $2 $1_with_nodes;		# Combine with the graph, so we have all the nodes of every clique
	snalight.compute_associated_nodes $1_with_nodes $3;		 # Add associted nodes

	update snalight.combine_associated_nodes_with_communities $3;		 # Combine associated with nominal elemnets (to be revised for full compatibility)
	update snalight.remove_unnecessary_cliques $3;			# Remove unnecessary cliques

	rm $1_with_nodes -f;
	}

	help
	{
	"Add associated nodes to a list of cliques"
	"Note that the graph is again necessary as the second input parameter"
	}

}



map combine_associated_nodes_with_communities
{
	in snalight.Clique snalight.Clique
	#out snalight.Clique system.Void
	out snalight.Clique snalight.Clique

	help
	{
	"Combine the output of snalight.add_associated_nodes in order to get communities with all nodes"
	}
}

#=====================
#Calculate metrics
#=====================



#MASP

script metrics_graph_to_metrics_of_reach_nodes
{
	in	system.UInt snalight.Node # (1) graph
	out system.UInt snalight.Metric_Reach # (2) Metrics of nodes reached

	top

	help
	{
	"..."
	}

	code
	{
	rm $1_assoc -f;
	rm $1_with_flags -f;

	snalight.metrics_generate_reach_nodes $1 $1_assoc;
	snalight.metrics_add_flags_reached_nodes $1_assoc $1 $1_with_flags;
	snalight.metrics_calculate_metrics_reach_nodes $1_with_flags $2;

	rm $1_assoc -f;
	rm $1_with_flags -f;
	}


}

map metrics_generate_reach_nodes
{
	in system.UInt snalight.Node
	out system.UInt snalight.Node_Reach

	help
	{
	"..."
	}
}


reduce metrics_add_flags_reached_nodes
{
	in system.UInt snalight.Node_Reach
	in system.UInt snalight.Node
	out system.UInt snalight.Node_Reach

	help
	{
	"..."
	}
}

reduce metrics_calculate_metrics_reach_nodes
{
	in system.UInt snalight.Node_Reach
	out system.UInt snalight.Metric_Reach

	help
	{
	"..."
	}
}

script metrics_graph_to_metrics_of_nodes
{
	in	system.UInt snalight.Node # (1) graph
	out system.UInt snalight.Metric # (2) Metrics of nodes

	top

	help
	{
	"..."
	}

	code
	{
	rm $1_assoc -f;
	rm $1_with_flags -f;

	snalight.metrics_generate_contact_nodes $1 $1_assoc;
	snalight.metrics_add_flags_reached_nodes $1_assoc $1 $1_with_flags;
	snalight.metrics_calculate_node_metrics $1_with_flags $2;

	rm $1_assoc -f;
	rm $1_with_flags -f;
	}


}

reduce metrics_calculate_node_metrics
{
	in system.UInt snalight.Node_Reach
	out system.UInt snalight.Metric

	help
	{
	"..."
	}
}

map metrics_generate_contact_nodes
{
	in system.UInt snalight.Node
	out system.UInt snalight.Node_Reach

	help
	{
	"..."
	}
}


map metrics_spread_communities_nodes
{
	in snalight.Clique snalight.Clique
	out system.UInt snalight.Node_Communities

	help
	{
	"..."
	}
}

reduce metrics_add_weight_to_node_comm
{
	in system.UInt snalight.Node_Communities
	in system.UInt snalight.Node
	out snalight.Clique snalight.Node_Comm_Weight

	help
	{
	"..."
	}
}


reduce metrics_calculate_community_metrics
{
	in snalight.Clique snalight.Node_Comm_Weight
	out snalight.Clique snalight.Metric_Communities

	help
	{
	"..."
	}
}

reduce metrics_add_id_community_metrics
{
	in snalight.Clique snalight.Metric_Communities
	in snalight.Clique snalight.Community
	out snalight.Clique snalight.Metric_Communities

	help
	{
	"..."
	}
}

script metrics_graph_to_metrics_of_communities
{
	in	snalight.Clique snalight.Clique		# (1) community
	in	system.UInt snalight.Node			# (2) graph
	out system.UInt snalight.Metric_Communities		# (3) Metrics of communities

	top

	help
	{
	"..."
	}

	code
	{
	rm $1_assoc -f;
	rm $1_with_weight -f;

	snalight.metrics_spread_communities_nodes $1 $1_assoc;
	snalight.metrics_add_weight_to_node_comm $1_assoc $2 $1_with_weight;
	snalight.metrics_calculate_community_metrics $1_with_weight $3;

	rm $1_assoc -f;
	rm $1_with_weight -f;
	}
}


reduce metrics_calculate_node_communities_metrics
{
	in system.UInt snalight.Node_Communities
	in system.UInt snalight.Node
	out system.UInt snalight.Metric_Node_Communities

	help
	{
	"..."
	}
}

script metrics_graph_to_metrics_of_node_communities
{
	in	snalight.Clique snalight.Clique			 # (1) community
	in	system.UInt snalight.Node			 # (2) graph
	out system.UInt snalight.Metric_Node_Communities		# (3) Metrics of snalight.Node-communities

	top

	help
	{
	"..."
	}

	code
	{
	rm $1_assoc -f;

	snalight.metrics_spread_communities_nodes $1 $1_assoc;
	snalight.metrics_calculate_node_communities_metrics $1_assoc $2 $3;

	rm $1_assoc -f;

	}
}

reduce metrics_aggrate_node_metrics
{
	in system.UInt snalight.Metric
	in system.UInt snalight.Metric_Node_Communities
	in system.UInt snalight.Metric_Reach
	in system.UInt snalight.Metric_Cluster
	out system.UInt snalight.Metric_Node_complete

	help
	{
	"..."
	}
}


reduce metrics_aggrate_comm_reach_metrics
{
	in snalight.Clique snalight.Metric_Communities
	in snalight.Clique snalight.Metric_Reach_Comm
	out snalight.Clique snalight.Metric_Communities

	help
	{
	"..."
	}
}


map metrics_spread_communities
{
	in system.UInt snalight.Node
	out snalight.Clique system.UInt

	help
	{
	"..."
	}
}


reduce metrics_spread_communities_nodes_cluster
{
	in snalight.Clique system.UInt
	out system.UInt snalight.Metric_Cluster_Intermediate

	help
	{
	"..."
	}
}

reduce metrics_count_links_comm_cluster
{
	in system.UInt snalight.Metric_Cluster_Intermediate
	in system.UInt snalight.Node
	out snalight.Clique snalight.Metric_Cluster_Intermediate

	help
	{
	"..."
	}
}

reduce metrics_calculate_density_metric_cluster
{
	in snalight.Clique snalight.Metric_Cluster_Intermediate
	out snalight.Clique snalight.Metric_Cluster_Intermediate

	help
	{
	"..."
	}
}

reduce metrics_calculate_cluster
{
	in snalight.Clique system.UInt
	in snalight.Clique snalight.Metric_Cluster_Intermediate
	out system.UInt snalight.Metric_Cluster

	help
	{
	"..."
	}
}


script metrics_graph_to_metrics_of_node_cluster
{
	in	system.UInt snalight.Node			 # (1) graph
	out system.UInt snalight.Metric_Node_Communities		# (2) Metrics of snalight.Node-communities

	top

	help
	{
	"..."
	}

	code
	{
	rm $1_spread_cluster -f;
	rm $1_nodes_cluster -f;
	rm $1_links_cluster -f;

	snalight.metrics_spread_communities $1 $1_spread_cluster;
	snalight.metrics_spread_communities_nodes_cluster $1_spread_cluster $1_nodes_cluster;
	snalight.metrics_count_links_comm_cluster $1_nodes_cluster $1 $1_links_cluster;
	update snalight.metrics_calculate_density_metric_cluster $1_links_cluster;
	snalight.metrics_calculate_cluster $1_spread_cluster $1_links_cluster $2;

	rm $1_spread_cluster -f;
	rm $1_nodes_cluster -f;
	rm $1_links_cluster -f;

	}
}

reduce metrics_join_communities_with_nodes
{
	in system.UInt snalight.Clique
	in system.UInt snalight.Node
	out snalight.Clique snalight.Metric_Reach_Comm_intemediate

	help
	{
	"..."
	}
}

reduce metrics_calculate_reach_one_node
{
	in snalight.Clique snalight.Metric_Reach_Comm_intemediate
	out snalight.Clique snalight.Metric_Reach_Comm
	out snalight.Clique snalight.Clique

	help
	{
	"..."
	}
}

map metrics_spread_adjacent_nodes
{
	in snalight.Clique snalight.Clique
	out system.UInt snalight.Clique

	help
	{
	"..."
	}
}

reduce metrics_join_adjacent_nodes
{
	in system.UInt snalight.Clique
	in system.UInt snalight.Clique
	out snalight.Clique snalight.Vector_Clique

	help
	{
	"..."
	}
}


reduce metrics_calculate_reach_one_comm
{
	in snalight.Clique snalight.Vector_Clique
	in snalight.Clique snalight.Metric_Reach_Comm
	out snalight.Clique snalight.Metric_Reach_Comm

	help
	{
	"..."
	}
}


reduce metrics_add_id_node_in_community_metrics
{
	in snalight.Clique snalight.Metric_Node_In_Comm
	in snalight.Clique snalight.Community
	out snalight.Clique snalight.Metric_Node_In_Comm

	help
	{
	"..."
	}
}


script metrics_graph_to_metrics_of_node_in_communities
{
	in	system.UInt snalight.Node			 # (1) graph
	in	snalight.Clique snalight.Clique		 # (2) community
	out system.UInt snalight.Metric_Node_In_Comm		# (3) snalight.Metrics of snalight.Node-communities

	top

	help
	{
	"..."
	}

	code
	{
	rm $2_void -f;
	rm $2_spread -f;
	rm $2_join -f;

	remove_values $2 $2_void;
	snalight.spread_cliques_per_node $2_void $2_spread;
	snalight.metrics_join_node_for_node_in_comm $2_spread $1 $2_join;
	snalight.metrics_calculate_node_in_comm $2_join $3;

	rm $2_void -f;
	rm $2_spread -f;
	rm $2_join -f;

	}
}

reduce metrics_join_node_for_node_in_comm
{
	in system.UInt snalight.Clique
	in system.UInt snalight.Node
	out snalight.Clique snalight.Metric_Node_In_Comm_Intermediate

	help
	{
	"..."
	}
}

reduce metrics_calculate_node_in_comm
{
	in snalight.Clique snalight.Metric_Node_In_Comm_Intermediate
	out snalight.Clique snalight.Metric_Node_In_Comm

	help
	{
	"..."
	}
}


script metrics_graph_to_metrics_of_reach_comm
{
	in	system.UInt snalight.Node			 # (1) graph
	in	snalight.Clique snalight.Clique			 # (2) community
	out system.UInt snalight.Metric_Reach_Comm		# (3) snalight.Metrics of reach of communities

	top

	help
	{
	"..."
	}

	code
	{
	rm $2_void -f;
	rm $2_spread -f;
	rm $2_with_nodes -f;
	rm $2_metric_temp -f;
	rm $2_clique -f;
	rm $2_adj -f;
	rm $2_vector_clique -f;

	remove_values $2 $2_void;
	snalight.spread_cliques_per_node $2_void $2_spread;
	snalight.metrics_join_communities_with_nodes $2_spread $1 $2_with_nodes;
	snalight.metrics_calculate_reach_one_node $2_with_nodes $2_metric_temp $2_clique;
	snalight.metrics_spread_adjacent_nodes $2_clique $2_adj;
	snalight.metrics_join_adjacent_nodes $2_spread $2_adj $2_vector_clique;
	snalight.metrics_calculate_reach_one_comm $2_vector_clique $2_metric_temp $3;

	rm $2_void -f;
	rm $2_spread -f;
	rm $2_with_nodes -f;
	rm $2_metric_temp -f;
	rm $2_clique -f;
	rm $2_adj -f;
	rm $2_vector_clique -f;

	}
}

parserOut metric_nodes_out
{
	in	system.UInt snalight.Metric_Node_complete

	setup

	help
	{
	"Convert metrics of node to txt"
	}
}

parserOut metric_communities_out
{
	in	snalight.Clique snalight.Metric_Communities

	setup

	help
	{
	"Convert metrics of community to txt"
	}
}

parserOut metric_nodes_in_communities_out
{
	in	snalight.Clique snalight.Metric_Node_In_Comm

	setup

	help
	{
	"Convert metrics of community to txt"
	}
}



parserOut communities_unique_id_out
{
	in	snalight.Clique snalight.Community

	setup

	help
	{
	"Convert communities of level 3 to txt"
	}
}


parserOut social_graph_out
{
	in	system.UInt snalight.Node

	setup

	help
	{
	" Convert Social Graph to txt phoneA|phoneB|weight|dir."
	" When used with -duplicated every link will be printed, if not, only links where phoneA < phoneB are printed"
	" When used with -extern_mark a fifth column will be included indicating if phoneA is extern or subscriber"
	}
}

parserOut social_graph_parse_out_sinks
{
	in	system.UInt snalight.Node

	setup

	help
	{
	" Get sink nodes from graph and print	phone|strong_contacts|weak_contacts. "
	" Thresholds for sink nodes on maximum strong and/or weak contacts will be configured (default 50,400) "
	}
}




map generate_comm_unique_id
{
	in snalight.Clique snalight.Clique
	out snalight.Clique snalight.Community

	top

	help
	{
	"Assign a unique identifier to each clique"
	}

}

script compute_all_metric
{
	in	system.UInt snalight.Node			 # (1) directory graph
	in	snalight.Clique snalight.Community			# (2) directory comm_id
	in	system.String system.Void				# (3) prefix for TXT outputs
	out system.Void system.Void

	top

	help
	{
	"..."
	}

	code
	{
	# Remove tmp files
	rm $3_node_metrics_txt -f;
	rm $3_community_metrics_txt -f;
	rm $3_com_member_metrics_txt -f;

	rm $2_gen -f;

	rm $1_metric_nodes -f;
	rm $1_metric_node-comm -f;
	rm $1_metric_reach_nodes -f;
	rm $1_metric_cluster -f;
	rm $1_metric_node_comp -f;

	rm $1_metric_comm -f;
	rm $1_metric_comm_reach -f;
	rm $1_metric_comm_completed -f;
	rm $1_metric_comm_id -f;

	rm $1_metric_comm_members_id -f;
	rm $1_metric_comm_members -f;

	snalight.gen_comm_clique $2 $2_gen;

	snalight.metrics_graph_to_metrics_of_nodes $1 $1_metric_nodes;
	snalight.metrics_graph_to_metrics_of_node_communities $2_gen $1 $1_metric_node-comm;
	snalight.metrics_graph_to_metrics_of_reach_nodes $1 $1_metric_reach_nodes;
	snalight.metrics_graph_to_metrics_of_node_cluster $1 $1_metric_cluster;

	snalight.metrics_aggrate_node_metrics $1_metric_nodes $1_metric_node-comm $1_metric_reach_nodes $1_metric_cluster $1_metric_node_comp;

	rm $1_metric_nodes -f;
	rm $1_metric_node-comm -f;
	rm $1_metric_reach_nodes -f;
	rm $1_metric_cluster -f;

	snalight.metric_nodes_out $1_metric_node_comp $3_node_metrics_txt;

	snalight.metrics_graph_to_metrics_of_communities $2_gen $1 $1_metric_comm;
	snalight.metrics_graph_to_metrics_of_reach_comm $1 $2_gen $1_metric_comm_reach;
	snalight.metrics_aggrate_comm_reach_metrics $1_metric_comm $1_metric_comm_reach $1_metric_comm_completed;
	snalight.metrics_add_id_community_metrics $1_metric_comm_completed $2 $1_metric_comm_id;
	snalight.metric_communities_out $1_metric_comm_id $3_community_metrics_txt;

	rm $1_metric_comm_reach -f;
	rm $1_metric_comm_completed -f;

	snalight.metrics_graph_to_metrics_of_node_in_communities $1 $2_gen $1_metric_comm_members;
	snalight.metrics_add_id_node_in_community_metrics $1_metric_comm_members $2 $1_metric_comm_members_id;
	snalight.metric_nodes_in_communities_out $1_metric_comm_members_id $3_com_member_metrics_txt;

	rm $1_metric_node_comp -f;
	rm $1_metric_comm_completed -f;
	rm $1_metric_comm_id -f;
	rm $1_metric_comm_members_id -f;
	rm $1_metric_comm_members -f;
	rm $1_metric_comm -f;

	rm $2_gen -f;
	}
}


#MASP


# ---------------------------------------------------------------------------
# Datas for snalight
# ---------------------------------------------------------------------------

# Link: Connection between two telephone numbers

data Link
{
	 system.UInt id;
	 system.Float weight;
	 system.Float dir;
}



# Operations with cdrs
# -------------------------------------------------

reduce replace_callee_phone
{
	in system.UInt snalight.CDR
	in system.UInt snalight.User
	out system.UInt snalight.CDR

	help
	{
	"Operation especially designed for the JAJAH CDRs."
	"Replaces the callee phone number in a CDR for their memberID, if exists. If the ID doesn't exist it is assumed it's not a client"
	"and thus the original phone number is left unchanged."
	"IN: CDR dataset containing as key the callee phone number."
	"IN: User dataset of clients containing as key the client phone number."
	"OUT: CDR dataset with the callee number replaced, if needed. The key will be the Caller ID"
	}
}

generator fake_cdrs
{
	out system.UInt snalight.CDR

	help
	{
	"Generate a ranom set of cdrs from a group of 1000 users. 20% of the CDRs are duplicated"
	}
}

parser parse_cdrs
{
	out system.UInt snalight.CDR

	setup

	help
	{
	"Parse txt-file of CDRS in	different formats."
	"This is a generic parse for different formats. Please, specify with the -format <format>"
	"Suported formats:"
	"TME:	 --> 1|689644587|685015313|01/09/08 18:52:44|123|2|2"
	"JAJAH: --> 173731833|182385|390817917344|393333303646|2010-01-01 00:00:00|0|SMS"
	"TASA:	--> 29148153389|29145442400|29/01/2009|526|0.1700000000"
	" This function in the Jajah format yields an output that doesn't contain the member ID of the MemberB, only the phone number."
	" Thus, an additional step is necessary after this parsing. For that purpose, the key of this dataset will be the MemberB Phone number"
	" instead of the MemberA userID. thanks to this, the set can be combined with a [UserPhone - User] Data set in a reduce operation"
	" to replace the MemberB Phone for the MemberB userID, if exists."
	}
}







# Operations with graphs
# -------------------------------------------------


reduce add_extern_mark_to_graph
{
	in system.UInt snalight.Node
	in system.UInt snalight.User
	out system.UInt snalight.Node

	help
	{
	"Operation to cross a graph set (UInt-Node) with a file containing information about the user"
	"It is only used to set the extern flag in the node elements where we do not have information about the user"
	}
}

reduce filter_graph_reduce
{
	in	system.UInt snalight.Node
	out system.UInt snalight.Node

	help
	{
	"Second phase of the filter-graph process."
	"Here we only detect if a \"killing node\" has been sent in the first phase to remove a node"
	}
}

map filter_graph_map
{
	in	system.UInt snalight.Node
	out system.UInt snalight.Node

	setup

	help
	{
	"First phase of the filter-graph process. Please contcatenate wiht snalight.filter_reduce to perform the filter graph"
	"In this first step, graph elements are simply put at the output if they are correct."
	"If they are not correct, a \"kill-node\" is send at the output to all its connections to be removed in the second phase"
	"Use -only_extreme to filter out only nodes with over 2 * max_connections"
	}

}

reduce get_graph_from_links2
{
	in	system.UInt graph.Link
	out system.UInt snalight.Node

	help
	{
	"Build a graph by combining links at the input.";
	"Links are not suppoused to be duplicated at the input. This is commonly used where we have a txt-file with links"
	}

}


map select_nodes_from_graph
{
	in system.UInt snalight.Node
	out system.UInt snalight.Node

	setup

	help
	{
	"Tool used to select some elements of a graph."
	"Selected nodes are indicated at command line with	-nodes node1 node2 node3";
	"If -customers is indicated in command line, telefonica nodes are selected"
	}
}


parser parse_links
{
	out system.UInt graph.Link

	setup

	help
	{
	"Parse a graph in txt format. Every link is suppoused to be a connection "
	"Format for each line: 925513947|657056810|0.25 "
	"The output emits two key-values for each row (in both directions of the link)"
	"If we only want to emit a single output add -no_duplicate at the output"
	}
}

generator fake_graph
{
	out system.UInt snalight.Node

	setup

	help
	{
	"Generate some example of simple graphs. Type -example 1 or -example 2 ... to get different examples\n"
	}
}

#Operations for temporal weighting
#-------------------------------------------------------------------------------------

#MASP
map nodes_to_links
{
	in system.UInt snalight.Node
	out snalight.Link_Edges graph.Link

	help
	{
	"Generate one [Link_Edges, Link] for each Link in a node."
	}
}

reduce calculate_links_temporal_weighting
{

	in snalight.Link_Edges graph.Link	#History Graph
	in snalight.Link_Edges graph.Link	#Month 1
	in snalight.Link_Edges graph.Link	#Month 2
	in snalight.Link_Edges graph.Link	#Month 3
	in snalight.Link_Edges graph.Link	#Month 4
	in snalight.Link_Edges graph.Link	#Month 5

	out system.UInt graph.Link		 #Ponderate Link
	out system.UInt graph.Link		 #New Link for History Graph

	setup

	help
	{
	"Calculate temporal weighting for each Link."
	}
}

map search_node_in_graph
{
	in system.UInt snalight.Node
	out system.UInt snalight.Node

	setup

	help
	{
	"Search a node in the graph. "
	"Usage snalight.search_node_in_graph [graph] [result filename] -nodeId [id of node to search]"
	}
}

# Operations with snalight.Cliques
# ---------------------------------------------

parser parse_cliques_as_cliques_groups
{
	out system.UInt system.UInt

	help
	{
	"Parse a file with a set of cliques in the \"per-line-format\":"
	"1|node1"
	"1|node2"
	"1|node3"
	"2|node1"
	"2|node2"
	"3|node1"
	"3|node2"
	"...."
	}
}

reduce get_cliques_from_cliques_groups
{
	in	system.UInt system.UInt
	out snalight.Clique system.Void

	help
	{
	"Build a cliques set"
	"Input is suppoused to be a set of cliques whete each line is cliqueId - nodeID."
	"This type of input comes from external cliques-computation implementations "
	}

}

reduce get_cliques_from_cliques_groups2
{
	in	system.UInt system.UInt
	out snalight.Clique system.UInt

	help
	{
	"Build a cliques set"
	"Input is suppoused to be a set of cliques whete each line is cliqueId - nodeID."
	"This type of input comes from external cliques-finding implementations "
	}

}


# Operations with Communities
# ----------------------------------------

map spread_cliques_per_node
{
	in	snalight.Clique system.Void
	out system.UInt snalight.Clique

	help
	{
	"Spread the cliques in a per-node way."
	"For each input clique with N nodeIds, N outputs are emitted."
	"Output keys are the nodeIds. Outputs values are allways the same clique"
	"Example [ 1 2 3 ] -> "
	" [1][ 1 2 3 ]"
	" [2][ 1 2 3 ]"
	" [3][ 1 2 3 ]"
	}
}

reduce get_possible_cliques_links
{
	in	system.UInt snalight.Clique
	out system.UInt snalight.Clique2

	setup


	help
	{
	"Emit all possible links between cliques"
	"The input is suppoused to be a list of cliques spreaded with snalight.spread_cliques_per_node"
	""
	"The output are [UInt snalight.Clique2]"
	"Value (Clique2) is the possible link of cliques"
	"Key are each one of the nodeIds that are included in these two cliques"
	}
}


reduce get_clique_links_with_nodes
{
	in	system.UInt snalight.Clique2
	in	system.UInt snalight.Node
	out snalight.Clique2 snalight.Node

	help
	{
	"Combine the list of possible links between cliques obtained with snalight.get_possible_cliques_links with the graph"
	"The output are all the possible links between cliques with all the nodes needed to evaluate in this link is real\n"
	"At the output, we have the link between two cliques (key) and all the nodes (values)"
	}
}


reduce get_clique_links
{
	in	snalight.Clique2 snalight.Node
	out snalight.Clique snalight.Clique_Link

	setup

	help
	{
	"The input is suppoused to be the output of snalight.get_clique_links_with_nodes"
	"In this functions, links between cliques are evaluated. It they are real, they are emitted at the output"
	"Note that the input pairs of cliques are non-duplicated pairs.The output is duplicated to be able to create the graph in the next step"
	"Special flag -communities is introduced in the command line to indicate that community-fusion algorithms should be applyed"
	}
}

reduce select_clique_links_to_be_removed
{

	in	snalight.Clique snalight.Clique_Link
	out snalight.Clique snalight.Clique_Link

	setup

	help
	{
	"Emit the links between cliques that should be removed because thay are over 10-th rank"
	"The output list can be used against the same input to remove the unnecessary clique links"
	}
}


reduce compute_cliques_graph
{
	in	snalight.Clique	system.Void
	in	snalight.Clique snalight.Clique_Link
	out snalight.Clique snalight.Clique_Node

	help
	{
	"Compute the graph of cliques from the original set of cliques and the set of cliques links per each clique"
	}

}


map spread_cliques_graph
{
	in	snalight.Clique snalight.Clique_Node
	out snalight.Clique snalight.Clique_Node

	help
	{
	"Spread a graph of cliques. This process consist in taking each clique an emit an output for each one of the cliques we are connected to"
	}
}


reduce compute_new_cliques
{
	in	snalight.Clique snalight.Clique_Node
	out snalight.Clique snalight.Vector_Clique

	setup

	help
	{
	"Compute the cliques of cliques. The input is suppoused to be the output of snalight.spread_cliques_graph"
	}

}


reduce get_unnecessary_cliques
{
	in	system.UInt snalight.Clique
	out snalight.Clique system.Void

	help
	{
	"Get a list of unnecessary cliques"
	"Input is suppouse to be a list of cliques spreaded by node"
	"Unnecessary cliques are the ones that are included in bigger ones"
	}
}

reduce remove_duplicates
{
	in	system.UInt snalight.CDR
	out system.UInt snalight.CDR
	
	helpLine "Remove duplicated CDRs"

	help
	{
	"Remove duplicated CDRs"
	}
}

reduce remove_cliques
{
	in	snalight.Clique system.Void
	in	snalight.Clique system.Void
	out snalight.Clique system.Void

	help
	{
	"Remove cliques comming from the first input, and emit the rest at the output. The list of cliques to remove is provided at the second input"
	"It also remove duplicates since it only emit every clique at the input one".
	}
}

reduce remove_cliques_with_associated
{
	in	snalight.Clique snalight.Clique
	in	snalight.Clique system.Void
	out snalight.Clique snalight.Clique

	help
	{
	"Remove cliques comming from the first input, and emit the rest at the output. The list of cliques to remove is provided at the second input"
	"It also remove duplicates since it only emit every clique at the input one".
		"Returns also associated"
	}
}

script cross_cliques_with_nodes
{
	in	snalight.Clique	system.Void
	in	system.UInt	snalight.Node
	out snalight.Clique	snalight.Node

	code
	{
	rm $1_spread_per_node -f;
	snalight.spread_cliques_per_node $1 $1_spread_per_node;		 # Spread cliques to all components (nodeId)
	snalight.cross_cliques_nodes $1_spread_per_node $2 $3;			# Combine with the grapg
	rm $1_spread_per_node -f;
	}

	help
	{
	"Cross a list of cliques with the node information of a graph"
	}
}

reduce cross_cliques_nodes
{
	in	system.UInt snalight.Clique
	in	system.UInt snalight.Node
	out snalight.Clique snalight.Node

	help
	{
	"Cross a spread version of the cliques with the graph"
	"It allows us to have all the snalight.Nodes involved in a clique toguether"
	}
}


reduce compute_associated_nodes
{

	in	snalight.Clique	snalight.Node
	out snalight.Clique	snalight.Clique

	setup

	help
	{
	"Get the list of associated nodes of a clique"
	"The input is suppoused to be the output of snalight.cross_cliques_nodes"
	}
}

map spread_communities_to_links
{
	in snalight.Clique snalight.Clique
	out system.UInt snalight.Clique

	help
	{
	"Spreads the communitites into several values. For each node in a community, the operation creates a pair with that node ID as a key"
	"and the rest of the community as the value."
	"The input is the communities file extracted from a graph"
	"This is used along with the operation snalight.get_dyads to get the dyads of a Social Network."
	}
}

reduce get_dyads
{
	in system.UInt snalight.Node
	in system.UInt snalight.Clique
	out system.UInt graph.Link

	help
	{
	"Extracts the dyads out of a graph. The first input is the graph of the Social Network, the second input is the result of the"
	"previous operation snalight.spread_communities_to_links. The output is a list of dyads of the graph, in the form of system.UInt-Link (MemberA_ID - MemberB_ID Weight)"
	}
}

# Extra operations
# ---------------------

generator fake_users
{
	out system.UInt snalight.User

	help
	{
	"Generate a random set of users"
	}
}

parser parse_users
{
	out system.UInt snalight.User

	setup

	help
	{
	"Parse of Users information"
	"Parse the content of a file with information about users. Commontly the name of this file is ALFA_CARACT.TXT."
	"This is a generic parse for different formats. Please, specify with the -format <format>"
	"Suported formats:"
	"TME: 687562010|910000000001|1|07/04/06|2|49|28|2||"
	"JAJAH: 945164|33450541701|2006-12-11 10:56:46.710000000| outputs the key as the caller member ID"
	"JAJAHINTERM: 945164|33450541701|2006-12-11 10:56:46.710000000| outpus the key as the callee number"
	"TEMM: 6123456789 outputs the key as the phone number"
	}

}

parserOut cliques_info
{
	in snalight.Clique system.Void

	help
	{
	"Get some information about a list of cliques"
	}
}

parserOut nodes_info
{
	in	system.UInt snalight.Node

	help
	{
	"Get some information about a list of nodes (a graph)"
	}
}


parserOut study_set_of_nodes
{
	in	system.UInt snalight.Node

	setup

	help
	{
	"Study a set of nodes and its relationship."
	"Note that all input nodes are keep in memory."
	"This operation is intended to be used in quick analysis"
	}

}


map select_key_in_cliques_graph
{
	in	snalight.Clique snalight.Vector_Clique
	out snalight.Clique system.Void

	help
	{
	"Select the key of a clique graph"
	}

}


generator generate_single_clique
{
	out snalight.Clique system.Void

	setup

	help
	{
	"Create a record of a single clique with the nodes passed at command line"
	"At command	line please indicte -nodes	node1 node2 node3..."
	}

}

parser parse_id_id
{
	out system.UInt2 system.Void

	help
	{
	"Generic parser to get a system.UInt-UInt file set form a txt file with this format: number|number"
	"This is used for instace to get into macro results from SQL operations"
	}
}

# ACG
map acg_map_dup_cdrs
{
	in	system.UInt snalight.CDR
	out	 system.UInt snalight.CDR

	top

	help
	{
	"TO DO"
	}
}

reduce acg_red_cdrs_to_nodes
{
	in	system.UInt snalight.CDR
	out	 system.UInt snalight.Node

	top
	setup

	help
	{
	"TO DO"
	}
}



parser parse_links_gasset
{
	out	 snalight.Link_Edges graph.Link

	top

	help
	{
		"Parse a graph in txt format. Every link is supposed to be a connection "
		"Format for each line: 925513947|657056810|1.25|0.66"
		"The output emits two key-values for each row (in both directions of the link)"
	}
}


reduce red_links_add_3graph
{

	in snalight.Link_Edges graph.Link	#Graph 1
	in snalight.Link_Edges graph.Link	#Graph 2
	in snalight.Link_Edges graph.Link	#Graph 3

	out system.UInt graph.Link	 #Ponderate Link

	help
	{
		"Add up 3 graphs in Link format."
	}
}

map gen_comm_clique
{

	in	snalight.Clique snalight.Community	#Community [Clique-Community]
	out snalight.Clique snalight.Clique		 #Community [Clique-Clique]

	help
	{
		"Convert community to [Clique-Clique]"
	}
}

script add_3graphs
{
	in system.UInt snalight.Node #Graph 1
	in system.UInt snalight.Node #Graph 2
	in system.UInt snalight.Node #Graph 3

	out system.UInt snalight.Node


	help
	{
		"Add up 3 graphs in system.UInt snalight.Node format"
	}


	code
	{
		rm $1_links -f;
		rm $2_links -f;
		rm $3_links -f;
		rm $4_links -f;

		snalight.nodes_to_links $1 $1_links;
		snalight.nodes_to_links $2 $2_links;
		snalight.nodes_to_links $3 $3_links;

		snalight.red_links_add_3graph $1_links $2_links $3_links $4_links;
		snalight.get_graph_from_links2 $4_links $4;

		rm $1_links -f;
		rm $2_links -f;
		rm $3_links -f;
		rm $4_links -f;
	}

}



script graph_temporal_weighting
{
	in system.UInt snalight.Node #Graph 1 (hist)
	in system.UInt snalight.Node #Graph 2 (n-4)
	in system.UInt snalight.Node #Graph 3 (n-3)
	in system.UInt snalight.Node #Graph 4 (n-2)
	in system.UInt snalight.Node #Graph 5 (n-1)
	in system.UInt snalight.Node #Graph 6 (n - current)
	in txt txt	 #TXT 7 (subscriber list)

	out system.UInt snalight.Node #Graph 8 (new hist - bin)
	out system.UInt snalight.Node #Graph 9 (weighted combined graph - bin)
	#out txt txt	 #TXT 10 (weighted combined graph - txt)
	#out txt txt	 #TXT 11 Sink nodes


	help
	{

		"Temporal weighting, 6 graphs as input and subscribers list. Returns two graphs: new history and combined"
	}

	code
	{
		rm $1_links -f;
		rm $2_links -f;
		rm $3_links -f;
		rm $4_links -f;
		rm $5_links -f;
		rm $6_links -f;
		rm $7_bin -f;
		rm $8_links -f;
		rm $9_links -f;
		rm $9_pre -f;
		rm $9_wsubs -f;
		rm $9_wkill -f;
		
		snalight.nodes_to_links $1 $1_links;
		snalight.nodes_to_links $2 $2_links;
		snalight.nodes_to_links $3 $3_links;
		snalight.nodes_to_links $4 $4_links;
		snalight.nodes_to_links $5 $5_links;
		snalight.nodes_to_links $6 $6_links;

		snalight.calculate_links_temporal_weighting $1_links $2_links $3_links $4_links $5_links $6_links $9_links $8_links;

		rm $1_links -f;
		rm $2_links -f;
		rm $3_links -f;
		rm $4_links -f;
		rm $5_links -f;
		rm $6_links -f;

		snalight.get_graph_from_links2	$8_links $8;
		snalight.get_graph_from_links2	$9_links $9_pre;

		snalight.parse_users $7 $7_bin -format TEMM;
		snalight.add_extern_mark_to_graph $9_pre $7_bin $9_wsubs;

		snalight.social_graph_parse_out_sinks $9_wsubs $9_sinks_txt;

		snalight.filter_graph_map $9_wsubs $9_wkill;
		snalight.filter_graph_reduce $9_wkill $9;

		rm $7_bin -f;
		rm $8_links -f;
		rm $9_links -f;
		rm $9_pre -f;
		rm $9_wsubs -f;
		rm $9_wkill -f;

		snalight.social_graph_out $9 $9_graph_txt;
	}


}

parser parse_links_gasset2
{
	out	 system.UInt graph.Link

	top

	help
	{
		"Parse a graph in txt format. Every link is supposed to be a connection "
		"Format for each line: 925513947|657056810|1.25|0.66"
		"The output emits two key-values for each row (in both directions of the link)"
	}
}


script parse_links_gasset_to_nodes
{
	in txt txt
	out system.UInt snalight.Node

	top

	help
	{
		"Transform a txt-based file with a graph into a macro-binary graph with key-value [UInt snalight.Node]"
		"The input graph is suppoused to be a list of connections between nodes"
		"A B for each line where A < B"
	}

	code
	{
		rm $1_links -f;
		snalight.parse_links_gasset2 $1 $1_links;	 # Parse links emiting two outputs per line
		snalight.get_graph_from_links2 $1_links $2;	 # collapse all links into a graph
		rm $1_links -f;
	}

}

