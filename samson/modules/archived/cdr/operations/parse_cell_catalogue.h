/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_cdr_parse_cell_catalogue
#define _H_SAMSON_cdr_parse_cell_catalogue


#include <samson/module/samson.h>

#include "cdr_parse_fields.h"


namespace samson{
namespace cdr{


	class parse_cell_catalogue : public samson::Parser
	{

	public:

		bool (parse_cell_catalogue ::*_gstGetCellInfo)( char *line, Cell *cell );


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

output: system.UInt32 cdr.Cell

helpLine: Parse the cell catalogue.
extendedHelp: 		Parse the cell catalogue.

#endif // de INFO_COMMENT



///(TEMM specific)
///Function to parse a line and convert it into
///a cell structure; used to
///parse the cell catalogue.
///
///@param line Pointer to the line to be parsed.
///@param cell Pointer to the cell structure.
///
///@return TRUE if successful parsing, FALSE in case
///   of error.
bool gstGetCellInfo_MX( char *line, Cell *cell ){
  uint32_t _cellId;
  size_t _btsId;
  size_t _lacId;
  size_t _stateId;
  char *_endptr;
  unsigned int _pos = 0;
  unsigned int _pos_field = 0;

  try{
    // cell id
    cdrGetNextField( line, &_pos, &_pos_field );
    cdrStrCellToInt( line+_pos_field, &_cellId );
    if( _cellId != 0 ){
      cell->cellId.value = _cellId;
    }else{
      throw false;
    }

    // BTS id
    cdrGetNextField( line, &_pos, &_pos_field );
    _btsId = (unsigned long)strtoul( line+_pos_field, &_endptr, 10 );
    if( *_endptr == '\0' ){
      cell->btsId.value = _btsId;
    }else{
      throw false;
    }

    // council id
    cdrGetNextField( line, &_pos, &_pos_field );
    _lacId = (unsigned long)strtoul( line+_pos_field, &_endptr, 10 );
    if( *_endptr == '\0' ){
      cell->lacId.value = _lacId;
    }else{
      throw false;
    }

    // state id
    cdrGetNextField( line, &_pos, &_pos_field );
    _stateId = (unsigned long)strtoul( line+_pos_field, &_endptr, 10 );
    if( *_endptr == '\0' ){
      cell->stateId.value = _stateId;
    }else{
      throw false;
    }
  }catch( ... ){
	  OLM_E(("Error parsing line:'%s' for cell", line));
    return false;
  }

 return true;
}



		void init( samson::KVWriter *writer )
		{
	   // To date, only data from Mexico are processed
	   _gstGetCellInfo = &parse_cell_catalogue::gstGetCellInfo_MX;
		}

void parseLines( char *line, samson::KVWriter *writer )
{
	//Datas to emit
	samson::system::UInt32 cellId;
	Cell cell;


	if( (this->*_gstGetCellInfo)( line, &cell ) == true ){
#define MAX_STR_LEN 1024
			//char output[MAX_STR_LEN];
			//ctime_r(&(cdr.time.value), output);
			//output[strlen(output)-1] = '\0';
			//OLM_T(LMT_User06, ("cdr: time: '%s', week_day: %d\n", output, int(cdr.week_day.value)));

		    cellId.value = cell.cellId.value;
			writer->emit(0, &cellId, &cell );

		}
		else
		{
			OLM_E(("Error parsing line:'%s' for cell", line));
			;
		}
	}

		void run( char *data , size_t length , samson::KVWriter *writer )
		{
			size_t offset = 0;
			size_t line_begin = 0;

			while( offset < length )
			{

				if( data[offset] == '\n')
				{
					data[offset] = '\0';

					parseLines(data+line_begin , writer);

					line_begin = offset+1;
				}
				++offset;
			}
		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace samson
} // end of namespace cdr

#endif
