/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_parse_users
#define _H_SAMSON_sna_parse_users


#include <samson/module/samson.h>

#include "sna_parsing_macros.h"
#include "sna_environment_parameters.h"


namespace samson{
namespace sna{

bool getUserFromLine_TME ( char*linea, samson::system::UInt*node, User* user)
{
	SNA_PARSER_INIT( linea )
	SNA_PARSER_NEXT_FIELD
	SNA_PARSER_GET_UINT( node->value )

	user->id = node->value;

	SNA_PARSER_NEXT_FIELD
	SNA_PARSER_GET_UINT( user->titularId );

	SNA_PARSER_NEXT_FIELD
	SNA_PARSER_GET_UINT8( user->type );


	SNA_PARSER_NEXT_FIELD
	SNA_PARSER_GET_DATE( user->activationDate );
	//MRData_Date_computeDayOfTheWeek( &user.activationDate );

	//rest of the fields not interesting right now..
	return true;
}

bool getUserFromLine_JAJAH_interm ( char*linea, samson::system::UInt*node, User* user)
{
	SNA_PARSER_INIT( linea )
	SNA_PARSER_NEXT_FIELD
	//Member ID
	SNA_PARSER_GET_UINT( user->id )

	SNA_PARSER_NEXT_FIELD
	//Member Phone

	//Something must be done here.....
	//by the moment we will have as many users as phone numbers. Some of them will share the same user ID
	SNA_PARSER_GET_UINT( user->titularId )

	//Current key: phone number rather than member ID
	*node = user->titularId;


	SNA_PARSER_NEXT_FIELD
	//Activation date

	user->activationDate.year		= CHAR_TO_INT( line[pos_field+2] ) *10 + CHAR_TO_INT( line[pos_field+3] );
	user->activationDate.month		= CHAR_TO_INT( line[pos_field+5] ) *10 + CHAR_TO_INT( line[pos_field+6] );
	user->activationDate.day		= CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );

	//rest of the fields not interesting right now..
	return true;
}



bool getUserFromLine_JAJAH ( char*linea, samson::system::UInt*node, User* user)
{
	SNA_PARSER_INIT( linea )
	SNA_PARSER_NEXT_FIELD
	//Member ID. The key
	SNA_PARSER_GET_UINT( user->id )
	*node = user->id;

	SNA_PARSER_NEXT_FIELD
	//Member Phone

	//Something must be done here.....
	//by the moment we will have as many users as phone numbers. Some of them will share the same user ID
	SNA_PARSER_GET_UINT( user->titularId )

	SNA_PARSER_NEXT_FIELD
	//Activation date

	user->activationDate.year		= CHAR_TO_INT( line[pos_field+2] ) *10 + CHAR_TO_INT( line[pos_field+3] );
	user->activationDate.month		= CHAR_TO_INT( line[pos_field+5] ) *10 + CHAR_TO_INT( line[pos_field+6] );
	user->activationDate.day		= CHAR_TO_INT( line[pos_field+8] ) *10 + CHAR_TO_INT( line[pos_field+9] );

	//rest of the fields not interesting right now..
	return true;
}



bool getUserFromLine_TEMM ( char*linea, samson::system::UInt*node, User* user)
{
	SNA_PARSER_INIT( linea )
	SNA_PARSER_NEXT_FIELD
	//Member ID. The key
	SNA_PARSER_GET_UINT( user->id )
	*node = user->id;

	user->activationDate.year		= 0;
	user->activationDate.month		= 0;
	user->activationDate.day		= 0;
        user->titularId = 0;
        user->type = 0;
        user->age = 0;
        user->sex = 0;
        user->churnCode = 0;
	user->churnDate.year		= 0;
	user->churnDate.month		= 0;
	user->churnDate.day		= 0;


	//rest of the fields not interesting right now..
        return true;
}




	class parse_users : public samson::Parser
	{
		typedef bool (*getUserFunction)( char*line, samson::system::UInt *node, User* user);
		getUserFunction _getUserFunction ;

	public:

		void init(samson::KVWriter *writer)
		{
			std::string format = environment->get( "sna.format_users", "TME");

			if( format.compare("TME")==0 )
				_getUserFunction = &getUserFromLine_TME;
			else if( format.compare("JAJAH")==0 )
				_getUserFunction = &getUserFromLine_JAJAH;
			else if( format.compare("JAJAHINTERM")==0 )
				_getUserFunction = getUserFromLine_JAJAH_interm;
			else if( format.compare("TEMM")==0 )
				_getUserFunction = &getUserFromLine_TEMM;
			else {
				OLM_E(("Error. Format not supported\n"));
				exit(1);
			}
		}


		void run( char *data , size_t length , samson::KVWriter *writer )
		{
			//Datas to emit
			samson::system::UInt node;
			User user;

			size_t offset = 0;
			size_t line_begin = 0;

			while( offset < length )
			{
				if( data[offset] == '\n' || data[offset] == '\0' )
				{
					data[offset] = '\0';

					if( _getUserFunction(data+line_begin , &node ,  &user ) )
					{
						writer->emit(0, &node, &user);
					}
					else
					{
						OLM_E(("Error parsing line:'%s' for User", data+line_begin));
					}

					line_begin = offset+1;
				}
				offset++;
			}
			if( _getUserFunction(data+line_begin , &node ,  &user ) )
			{
				writer->emit(0, &node, &user);
			}
			else
			{
				OLM_E(("Error parsing line:'%s' for User", data+line_begin));
			}
		}


	};


} // end of namespace samson
} // end of namespace sna

#endif
