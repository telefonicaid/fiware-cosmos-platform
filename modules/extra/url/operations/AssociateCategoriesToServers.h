
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_url_AssociateCategoriesToServers
#define _H_SAMSON_url_AssociateCategoriesToServers


#include <samson/module/samson.h>


/**********************************************************************
reduce AssociateCategoriesToServers
{
	in system.UInt url.CategoryVector	  # Server(id) - CategoryVector
	in system.UInt url.ServerCountVector  # Server(id) - Servers(Vector, with count)
	out system.UInt url.CategoryVector    # Server(id) - CategoryVector

	helpLine "Assign categories to every server, according to the common key. For every server in the vector, emits the server-categories kv"
}
***********************************************************************/

namespace samson{
namespace url{


	class AssociateCategoriesToServers : public samson::Reduce
	{
		samson::system::UInt serverIdRef;
		samson::system::UInt serverId;
		ServerCountVector servers;
		CategoryVector categories;
		CategoryVector categories_out;


	public:


		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
				if (inputs[0].num_kvs == 0)
				{
					if (inputs[1].num_kvs > 0)
					{
						serverIdRef.parse(inputs[1].kvs[0]->key);
						//OLM_T(LMT_User06,("We don't have category information for server:%d ", serverIdRef.value));
					}
					else
					{
						OLM_M(("We don't have category information for server, but there is no hit either"));
					}
					return;		// We don't have category information for that server
				}

				if (inputs[0].num_kvs != 1)
				{
					OLM_E(("We should have only one category vector per server: inputs[0].num_kvs:%d", inputs[0].num_kvs));
					return;
				}

				serverIdRef.parse(inputs[0].kvs[0]->key);
				categories.parse(inputs[0].kvs[0]->value);

				size_t num_categories = categories.category_length;

				categories_out.categorySetLength(num_categories);

				//OLM_T(LMT_User06,("Working with serverIdRef:%d ", serverIdRef.value));

				for (size_t i = 0; (i < inputs[1].num_kvs); i++)
				{
					servers.parse(inputs[1].kvs[i]->value);

					size_t countRef = servers.countRef.value;

					// One solution to incorporate count information to the process is to distribute an UniformWeight.
					// But this produces some smoothing.
					// Another option could be to keep that count relevance associated to the CategoryVector,
					// and use it when averaging through server keys in the next reduce

					//size_t uniformWeight = CategoryVector::double_2_intScaled(1.0 / double(num_categories));

					for (int j = 0; (j < servers.serversCount_length); j++)
					{
						serverId = servers.serversCount[j].server;
						//OLM_T(LMT_User06,("serverIdRef:%d serverId:%d with count:%d y countRef:%d", serverIdRef.value, serverId.value, servers.serversCount[j].count.value, countRef));
						if ((categories.fixed.value == 0) || (serverId != serverIdRef))
						{
							//OLM_T(LMT_User06,("Will emit serverIdRef:%d serverId:%d with count:%d y countRef:%d", serverIdRef.value, serverId.value, servers.serversCount[j].count.value, countRef));

							categories_out.fixed = categories.fixed;
							size_t count = servers.serversCount[j].count.value;
							double confidence = sqrt(countRef * count)/countRef;

							for (size_t k = 0; (k < num_categories); k++)
							{
								// New weight is computed directly with the scaled integers (perhaps losing precision)
								categories_out.category[k].weight = categories.category[k].weight;
								categories_out.category[k].confidence = CategoryVector::double_2_intScaled(confidence);
								categories_out.category[k].countServer.value = count;
								categories_out.category[k].countUser = count;
								//OLM_T(LMT_User06,("(\t cat[%d]:%d (count(%d) ", k, categories_out.category[k].weight.value, categories_out.category[k].countServer.value));
							}
							writer->emit(0, &serverId, &categories_out);
						}
					}
				}
		}


	};


} // end of namespace samson
} // end of namespace url

#endif
