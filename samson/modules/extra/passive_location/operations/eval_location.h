/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_passive_location_eval_location
#define _H_SAMSON_passive_location_eval_location


#include <samson/module/samson.h>
#include <samson/modules/mobility/Record.h>
#include <samson/modules/passive_location/UserLocActivityState.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/StringVector.h>
#include <samson/modules/system/UInt.h>
#include <samson/modules/system/DateComplete.h>
#include <samson/modules/system/Time.h>
#include <samson/modules/system/ComplexTimeSlot.h>

#include <stdint.h>

#include "pasloc_environment_parameters.h"


namespace samson{
namespace passive_location{


class eval_location : public samson::Reduce
{

    // User key
    samson::system::UInt user;
    // Input record
    samson::mobility::Record record;

    // state to log the user's activity
    UserLocActivityState locActivityState;

    // TimeSlots to characterize Home and Work
    samson::system::ComplexTimeSlot ctsH;
    samson::system::ComplexTimeSlot ctsW;
    int refDay;
    int lengthWindowDays;
    unsigned long thresholdDailyActivity;
    double thresholdTotalActivity;

    // Local variables to handle TimeSlot
    samson::system::DateComplete lDate;
    samson::system::Time lTime;

    // Intermediate variables
    samson::passive_location::LocActivity *locActivity;
    samson::passive_location::DailyActivity *dayActivity;
    // Intermediate variables to create a pruned output state
    UserLocActivityState new_locActivityState;
    samson::passive_location::LocActivity *new_locActivity;
    samson::passive_location::DailyActivity *new_dayActivity;

public:


    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: system.UInt mobility.Record
    //  input: system.UInt passive_location.UserLocActivityState
    //  output: system.UInt system.StringVector
    //  output: system.UInt passive_location.UserLocActivityState
    //
    // helpLine: Estimate home/work cellId, in streaming, with a UserLocActivityState
    //  END_INFO_MODULE

    void init( samson::KVWriter *writer )
    {
        refDay = environment->getInt(PASLOC_PARAMETER_CONF_REFDAY, PASLOC_PARAMETER_CONF_REFDAY_DEFAULT);
        if (refDay == PASLOC_PARAMETER_CONF_REFDAY_DEFAULT)
        {
            samson::system::TimeUnix now;
            now.value = time(NULL);
            now.getDateTimeFromTimeUTC(&lDate, &lTime);
            refDay = lDate.daysFrom2000_01_01();
        }

        // HOME
        // Mon-Fri from 00:00:00 to 07:00:00
        // Mon-Thu from 20:00:00 to 23:59:59
        // Sat-Sun from 08:00:00 to 12:59:59
        std::string conf_timeslot_home = environment->get(PASLOC_PARAMETER_CONF_TIMESLOT_HOME, PASLOC_PARAMETER_CONF_TIMESLOT_HOME_DEFAULT);
        ctsH.set( conf_timeslot_home );

        // WORK
        // Mon-Fri from 09:00:00 to 16:59:59
        std::string conf_timeslot_work = environment->get(PASLOC_PARAMETER_CONF_TIMESLOT_WORK, PASLOC_PARAMETER_CONF_TIMESLOT_WORK_DEFAULT);
        ctsW.set( conf_timeslot_work );

        LM_M(("home:'%s' and work:'%s'\n", conf_timeslot_home.c_str(), conf_timeslot_work.c_str()));
        lengthWindowDays = environment->getInt(PASLOC_PARAMETER_CONF_LENGTHWINDOWDAYS, PASLOC_PARAMETER_CONF_LENGTHWINDOWDAYS_DEFAULT);
        thresholdDailyActivity = environment->getSizeT(PASLOC_PARAMETER_CONF_THR_DAYACTIVITY, PASLOC_PARAMETER_CONF_THR_DAYACTIVITY_DEFAULT);
        thresholdTotalActivity = environment->getDouble(PASLOC_PARAMETER_CONF_THR_TOTALACTIVITY, PASLOC_PARAMETER_CONF_THR_TOTALACTIVITY_DEFAULT);
    }

    void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
    {
        if ( inputs[1].num_kvs == 0 )
        {
            // New user state
            locActivityState.init();
            user.parse( inputs[0].kvs[0]->key );
        }
        else
        {
            // Previous state
            locActivityState.parse( inputs[1].kvs[0]->value ); // We only consider one state
            user.parse( inputs[1].kvs[0]->key );
            if (inputs[1].num_kvs > 1)
            {
                LM_M(("Multiple states(%lu) for user:%lu", inputs[1].num_kvs, user.value));
            }
        }

        for (uint64_t i = 0 ; i < inputs[0].num_kvs ; i++ )
        {
            record.parse(inputs[0].kvs[i]->value);

            record.timestamp.getDateTimeFromTimeUTC(&lDate, &lTime);
            unsigned int uniqDay = lDate.daysFrom2000_01_01();

            // update state for home location
            if( ctsH.includes( &lDate, &lTime ) == true )
            {
                if (user.value == 7714066433)
                    LM_M(("For user:%lu, record:'%s' detects home", user.value, record.str().c_str()));
                int cellIdIdx = locActivityState.home.findCellID(record.cellId);
                if (cellIdIdx != -1)
                {
                    if (user.value == 7714066433)
                        LM_M(("For user:%lu, record:'%s' old home cell", user.value, record.str().c_str()));
                    locActivity = &(locActivityState.home.loc[cellIdIdx]);
                }
                else
                {
                    if (user.value == 7714066433)
                        LM_M(("For user:%lu, record:'%s' new home cell", user.value, record.str().c_str()));
                    locActivity = locActivityState.home.locAdd();
                    locActivity->init();
                    locActivity->cellId.value = record.cellId.value;
                }

                int dayIdx = locActivity->findDayActivity(uniqDay);
                if (dayIdx != -1)
                {
                    if (user.value == 7714066433)
                        LM_M(("For user:%lu, record:'%s' old home day", user.value, record.str().c_str()));
                    dayActivity = &(locActivity->dayActivity[dayIdx]);
                }
                else
                {
                    if (user.value == 7714066433)
                        LM_M(("For user:%lu, record:'%s' new home day", user.value, record.str().c_str()));
                    dayActivity = locActivity->dayActivityAdd();
                    dayActivity->init();
                    dayActivity->day.value = uniqDay;
                }
                dayActivity->hits.value++;
            }
            else
            {
                if (user.value == 7714066433)
                {
                    LM_M(("For user:%lu, record:'%s' does NOT detect home", user.value, record.str().c_str()));
                }
            }

            // update state for work location
            if( ctsW.includes( &lDate, &lTime ) == true )
            {
                if (user.value == 7714066433)
                    LM_M(("For user:%lu, record:'%s' detects work", user.value, record.str().c_str()));
                int cellIdIdx = locActivityState.work.findCellID(record.cellId);
                if (cellIdIdx != -1)
                {
                    if (user.value == 7714066433)
                        LM_M(("For user:%lu, record:'%s' old work cell", user.value, record.str().c_str()));
                    locActivity = &(locActivityState.work.loc[cellIdIdx]);
                }
                else
                {
                    if (user.value == 7714066433)
                        LM_M(("For user:%lu, record:'%s' new work cell", user.value, record.str().c_str()));
                    locActivity = locActivityState.work.locAdd();
                    locActivity->init();
                    locActivity->cellId.value = record.cellId.value;
                }

                int dayIdx = locActivity->findDayActivity(uniqDay);
                if (dayIdx != -1)
                {
                    if (user.value == 7714066433)
                        LM_M(("For user:%lu, record:'%s' old work day", user.value, record.str().c_str()));
                    dayActivity = &(locActivity->dayActivity[dayIdx]);
                }
                else
                {
                    if (user.value == 7714066433)
                        LM_M(("For user:%lu, record:'%s' new work day", user.value, record.str().c_str()));
                    dayActivity = locActivity->dayActivityAdd();
                    dayActivity->init();
                    dayActivity->day.value = uniqDay;
                }
                dayActivity->hits.value++;
            }
            else
            {
                if (user.value == 7714066433)
                {
                    LM_M(("For user:%lu, record:'%s' does NOT detect work", user.value, record.str().c_str()));
                }
            }
        }

#define MAX_STR_LEN 256
        char command[MAX_STR_LEN];
        uint64_t totalActivity;
        bool removeDays = false;
        uint32_t maxCellId;
        uint64_t maxCellIdActivity;
        samson::system::StringVector strCommand;

        // Evaluate home
        maxCellId = 0;
        maxCellIdActivity = 0;
        totalActivity = 0;
        for (int i = 0; (i < locActivityState.home.loc_length); i++)
        {
            locActivity = &(locActivityState.home.loc[i]);
            uint32_t cellId = locActivity->cellId.value;
            uint64_t cellIdActivity = 0;

            for (int j = 0; (j < locActivity->dayActivity_length); j++)
            {
                dayActivity = &(locActivity->dayActivity[j]);

                if (user.value == 7714066433)
                    LM_M(("For home user:%lu, cellId:%d, i:%d, j:%d, Checking (refDay(%d) - dayActivity(%d)) < window(%d)", user.value, cellId, i, j, refDay, int(dayActivity->day.value), lengthWindowDays));
                if ((refDay - int(dayActivity->day.value)) < lengthWindowDays)
                {
                    if (dayActivity->hits.value > thresholdDailyActivity)
                    {
                        cellIdActivity += dayActivity->hits.value;
                    }
                    totalActivity += dayActivity->hits.value;
                }
                else
                {
                    dayActivity->hits.value = 0;
                    if ((refDay - int(dayActivity->day.value)) > 2*lengthWindowDays)
                    {
                        removeDays = true;
                    }
                }
            }

            if (cellIdActivity > maxCellIdActivity)
            {
                maxCellId = cellId;
                maxCellIdActivity = cellIdActivity;
            }
        }

        if ((maxCellId != locActivityState.home.last_cellId.value) && (maxCellIdActivity/totalActivity > thresholdTotalActivity))
        {
            LM_M(("New home cellId:%u (last_home:%u), with maxCellIdActivity:%lu, totalActivity:%lu", maxCellId, locActivityState.home.last_cellId.value, maxCellIdActivity, totalActivity));

            strCommand.valuesSetLength(0);
            strCommand.valuesAdd()->value = "TRACK_ON";
            writer->emit(0, &user, &strCommand);

            strCommand.valuesSetLength(0);
            strCommand.valuesAdd()->value = "CELL_LABELLED_CREATE";
            strCommand.valuesAdd()->value = "home";
            snprintf(command , MAX_STR_LEN, "%u" , maxCellId);
            strCommand.valuesAdd()->value = command;
            writer->emit(0, &user, &strCommand);

            locActivityState.home.last_cellId.value = maxCellId;
        }

        // Evaluate work
        maxCellId = 0;
        maxCellIdActivity = 0;
        totalActivity = 0;
        for (int i = 0; (i < locActivityState.work.loc_length); i++)
        {
            locActivity = &(locActivityState.work.loc[i]);
            uint32_t cellId = locActivity->cellId.value;
            uint64_t cellIdActivity = 0;

            for (int j = 0; (j < locActivity->dayActivity_length); j++)
            {
                dayActivity = &(locActivity->dayActivity[j]);

                if (user.value == 7714066433)
                    LM_M(("For work user:%lu, cellId:%d, i:%d, j:%d, Checking (refDay(%d) - dayActivity(%d)) < window(%d)", user.value, cellId, i, j, refDay, int(dayActivity->day.value), lengthWindowDays));
                if ((refDay - int(dayActivity->day.value)) < lengthWindowDays)
                {
                    if (dayActivity->hits.value > thresholdDailyActivity)
                    {
                        cellIdActivity += dayActivity->hits.value;
                    }
                    totalActivity += dayActivity->hits.value;
                }
                else
                {
                    dayActivity->hits.value = 0;
                    if ((refDay - int(dayActivity->day.value)) > 2*lengthWindowDays)
                    {
                        removeDays = true;
                    }
                }
            }

            if (cellIdActivity > maxCellIdActivity)
            {
                maxCellId = cellId;
                maxCellIdActivity = cellIdActivity;
            }
        }

        if ((maxCellId != locActivityState.work.last_cellId.value) && (maxCellIdActivity/totalActivity > thresholdTotalActivity))
        {
            LM_M(("New work cellId:%u (last_work:%u), with maxCellIdActivity:%lu, totalActivity:%lu", maxCellId, locActivityState.work.last_cellId.value, maxCellIdActivity, totalActivity));

            strCommand.valuesSetLength(0);
            strCommand.valuesAdd()->value = "TRACK_ON";
            writer->emit(0, &user, &strCommand);

            strCommand.valuesSetLength(0);
            strCommand.valuesAdd()->value = "CELL_LABELLED_CREATE";
            strCommand.valuesAdd()->value = "work";
            snprintf(command , MAX_STR_LEN, "%u" , maxCellId);
            strCommand.valuesAdd()->value = command;
            writer->emit(0, &user, &strCommand);

            locActivityState.work.last_cellId.value = maxCellId;
        }

        if (removeDays)
        {
            LM_M(("removeDays activated"));

            UserLocActivityState new_locActivityState;
            new_locActivityState.init();

            for (int i = 0; (i < locActivityState.home.loc_length); i++)
            {
                locActivity = &(locActivityState.home.loc[i]);
                uint32_t cellId = locActivity->cellId.value;

                for (int j = 0; (j < locActivity->dayActivity_length); j++)
                {
                    dayActivity = &(locActivity->dayActivity[j]);
                    totalActivity += dayActivity->hits.value;
                    if (dayActivity->hits.value > 0)
                    {
                        if (new_locActivity == NULL)
                        {
                            new_locActivity = new_locActivityState.home.locAdd();
                            new_locActivity->init();
                            new_locActivity->cellId.value = cellId;
                        }

                        new_dayActivity = new_locActivity->dayActivityAdd();
                        new_dayActivity->copyFrom(dayActivity);
                    }
                }
            }

            for (int i = 0; (i < locActivityState.work.loc_length); i++)
            {
                locActivity = &(locActivityState.work.loc[i]);
                uint32_t cellId = locActivity->cellId.value;

                for (int j = 0; (j < locActivity->dayActivity_length); j++)
                {
                    dayActivity = &(locActivity->dayActivity[j]);
                    totalActivity += dayActivity->hits.value;
                    if (dayActivity->hits.value > 0)
                    {
                        if (new_locActivity == NULL)
                        {
                            new_locActivity = new_locActivityState.work.locAdd();
                            new_locActivity->init();
                            new_locActivity->cellId.value = cellId;
                        }

                        new_dayActivity = new_locActivity->dayActivityAdd();
                        new_dayActivity->copyFrom(dayActivity);
                    }
                }
            }
            writer->emit(1, &user, &new_locActivityState);

        }
        else
        {
            writer->emit(1, &user, &locActivityState);
        }
    }

    void finish( samson::KVWriter *writer )
    {
    }



};


} // end of namespace passive_location
} // end of namespace samson

#endif
