/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this data
 */

#ifndef _H_SAMSON_system_ComplexTimeSlot
#define _H_SAMSON_system_ComplexTimeSlot

#include <string>

#include <samson/modules/system/ComplexTimeSlot_base.h>
#include <samson/modules/system/Date.h>
#include <samson/modules/system/DateComplete.h>
#include <samson/modules/system/Time.h>
#include <samson/modules/system/TimeUnix.h>

namespace samson {
namespace system {

class ComplexTimeSlot : public ComplexTimeSlot_base {

  public:
    /**
     * Method to fill the array of simple time
     * slots with the values from the configuration
     * parameters.
     *
     * @param str String that contains the definition
     *    of the complex time slot, with the format:
     *    "N|TS1|...|TSN", being N the number of simple
     *    time slots, and TSi each of them in the format:
     *    "bbbbbbb hh:mm:ss hh:mm:ss".
     */
    void set(std::string str) {
      TimeSlot *_ts;
      unsigned int nts;

      flagSet.value = false;

      // fill members only the first time
      if (flagSet.value == false) {

        size_t _pos = 0;
        std::string _strTs = "";
        std::string _tmp = "";
        //unsigned char _wdaysMask;

        _pos = str.find('|', 0);
        if (_pos > 0) {
          nts = atoi(str.substr(0, _pos).c_str());

          // check length of the remaining substring
          // before inserting timeslot strings
          // into the array
          if (str.substr(_pos).length() == (26 * nts)) {
            // initialize total weekdays mask
            wdaysMask = WDAY_NONE;

            tsSetLength(nts);

            _pos++;
            for (unsigned int i = 0; i < nts; ++i) {
              _strTs = str.substr(_pos, 25);

              //_ts = tsAdd();
              _ts = ts + i;

              _ts->set(_strTs.c_str());

              // set position to next timeslot start
              _pos += 26;
            }
          } else {
            // error
            nts = 0;
          }

          // set flag in any case
          flagSet = true;
        }
      }
    }

    /**
     * Method that tests if a certain date
     * and time is included into the complex
     * time slot.
     *
     * @param date MACRO structure that stores the date.
     * @param time MACRO structure that stores the time.
     */
    bool includes(Date *date, Time *time) {
      for (int i = 0; i < ts_length; ++i) {
        if (ts[i].includes(date, time) == true) {
          return true;
        }
      }

      // if this point is reached, the time is not included
      // inside any of the simple timeslots of the complex one
      return false;
    }

    /**
     * Method that tests if a certain date
     * and time is included into the complex
     * time slot.
     *
     * @param date MACRO structure that stores the date.
     * @param time MACRO structure that stores the time.
     */
    bool includes(DateComplete *date, Time *time) {
      for (int i = 0; i < ts_length; ++i) {
        if (ts[i].includes(date, time) == true) {
          return true;
        }
      }

      // if this point is reached, the time is not included
      // inside any of the simple timeslots of the complex one
      return false;
    }

    /**
     * Method that tests if a certain date
     * and time is included into the complex
     * time slot.
     *
     * @param date MACRO structure that stores the date.
     * @param time MACRO structure that stores the time.
     */
    bool includes(TimeUnix *time) {
      for (int i = 0; i < ts_length; ++i) {
        if (ts[i].includes(time) == true) {
          return true;
        }
      }

      // if this point is reached, the time is not included
      // inside any of the simple timeslots of the complex one
      return false;
    }

    /**
     * Method that computes the week day of the date,
     * and the number of days in the month (to be used
     * in computing the covered days
     */
    void setWeekDayFirstDay(Date *date) {
      if (date->week_day_GetAssigned() == false) {
        date->compute_day_of_the_week();
      }
      wdayFirstDay.value = date->week_day.value;

      monthDays.value = date->GetMonthDays();
    }

    /**
     * Method that computes the week day of the date,
     * and the number of days in the month (to be used
     * in computing the covered days
     */
    void setWeekDayFirstDay(DateComplete *date) {
      if (date->week_day.value == 7) {
        date->compute_day_of_the_week();
      }
      wdayFirstDay.value = date->week_day.value;

      monthDays.value = date->GetMonthDays();
    }

    /**
     * Method that computes the number of days
     * covered by the time slot and sets the
     * corresponding member of the class.
     */
    void setCoveredDays() {
      unsigned char _mask;

      coveredDays.value = 0;

      for (int i = 0; i < 7; ++i) {
        _mask = static_cast<unsigned char>(::pow(2.0, i));

        if ((wdaysMask.value & _mask) == _mask) {
          coveredDays.value += 4;

          if (i == wdayFirstDay.value) {
            if (monthDays.value > 28)
              coveredDays.value++;
          } else if (i == ((wdayFirstDay.value + 1) % 7)) {
            if (monthDays.value > 29)
              coveredDays.value++;
          } else if (i == ((wdayFirstDay.value + 2) % 7)) {
            if (monthDays.value > 30)
              coveredDays.value++;
          }
        }
      }
    }

    /**
     * Method that returns the number of
     * days covered by the time slot.
     *
     * @return Value of class member coveredDays.
     */
    unsigned int getCoveredDays() {
      return coveredDays.value;
    }

};

} // end of namespace samson
} // end of namespace system

#endif
