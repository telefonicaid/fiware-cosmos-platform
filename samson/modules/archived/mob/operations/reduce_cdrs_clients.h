
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_mob_reduce_cdrs_clients
#define _H_SAMSON_mob_reduce_cdrs_clients


#include <samson/module/samson.h>
#include <samson/modules/system/Date.h>
#include <samson/modules/cdr/mobCdr.h>


namespace samson{
namespace mob{


class reduce_cdrs_clients : public samson::Reduce
{

	/**
	 * Sequential number to balance files when the
	 * CDR doesn't bring cell information.
	 */
	size_t seqFakeCellId;
	/**
	 * Month being processed.
	 */
	bool hasMonth;

	// Input[0k] & Output[1k]
	samson::system::UInt phone;

	// Input[0v] & Output[0v]
	samson::cdr::mobCdr cdr;

	// Output[0k]
	samson::system::UInt32 cellId;
	// Output[1v]
	MobilityDegree md;
	// Output[2k]
	samson::system::Date mob_month;
	// Output[2v]
	samson::system::Void void_data;

	/**
	 * Function to reset the fake cell id.
	 */
	void ResetFakeCellId()
	{
	  //OLM_T(LMT_User06, ("ResetFakeCellId"));
		seqFakeCellId = 0;
	}

	/**
	 * Function to compute a fake cell id,
	 * only useful to balance the size of
	 * the MACRO files.
	 *
	 * @param cellId Pointer to the fake cell id.
	 */
	void GetFakeCellId( samson::system::UInt32 *cellId )
	{
		seqFakeCellId++;
#define CONF_mob_CELLID_MIN	 100
		if( seqFakeCellId >= CONF_mob_CELLID_MIN )
		{
			seqFakeCellId = 0;
		}
		cellId->value = seqFakeCellId;
	}


public:

#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt system.Void
	input: system.UInt cdr.mobCdr
	output: system.UInt32 cdr.mobCdr
	output: system.UInt mob.MobilityDegree
	output: system.Date system.Void

	helpLine: Extract only CDRs where the TEF phone is in the client sample.
	extendedHelp: 		Extract only CDRs where the TEF phone is in the client sample.

#endif // de INFO_COMMENT

	/**
	 * Setup function before reducing CDR's.
	 * It calls the function to reset the
	 * value of the "fake" cell id.
	 */
	void init(samson::KVWriter *writer )
	{
		//OLM_T(LMT_User06, ("reduce_cdr_clients::init() with 0x%0x\n", this));
		ResetFakeCellId();
		hasMonth = false;
	}

	/**
	 * Reduce CDR's with the clients sample.
	 * Keep only those CDR's where the first phone
	 * belongs to the clients sample. Month being
	 * processed is also emitted for further use.
	 */
	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{


		if( inputs[0].num_kvs > 0 )
		{
			phone.parse(inputs[0].kvs[0]->key);
			//OLM_T(LMT_User06, ("reduce_cdr_clients::run() at 0x%0x: Starts run for phone:%lu with cdrs: inputs[1].num_kvs:%lu\n", this, phone.value, inputs[1].num_kvs));
			md.totalCalls = inputs[1].num_kvs;
			md.nationalCalls = 0;
			md.internationalCalls = 0;
			md.cellId.value = 0;
			md.cellCalls = 0;
			md.btsId = 0;
			md.btsCalls = 0;
			md.lacId = 0;
			md.lacCalls = 0;
			md.stateId = 0;
			md.stateCalls = 0;

			// Apparently, this counters are only incremented when cellId == 0, so we cannot do that now.
			// Instead, cdrs will still be emitted in next step, reduce_add_cell_info
			md.nationalCalls.value = 0;
			md.internationalCalls.value = 0;

			writer->emit(1, &phone, &md );

			for( size_t i=0; i<inputs[1].num_kvs; i++ )
			{
				cdr.parse( inputs[1].kvs[i]->value );
				// cellId.value = cdr.cellId;
				// we create fake cell ids in order to balance
				// the size of the files; otherwise, the
				// file_00000 would be too large, since
				// it would store all CDR's that do not
				// have cell info

				if( cdr.cellId.value == 0 )
				{
					GetFakeCellId( &(cellId) );
					//OLM_T(LMT_User06, ("For cdr.phone:%lu cdr without cellId, assigns cellId:%lu", cdr.phone.value, cellId.value));
				}
				else
				{
					cellId.value = cdr.cellId.value;
				}
				// get month being processed
				//if( mob_month.month == 0 )
				if(!hasMonth)
				{
					struct tm tm;

					cdr.timeUnix.getCalendarFromTimeUTC(&tm);

					mob_month.unassignAllOptionals();
					mob_month.year.value = tm.tm_year;
					mob_month.month.value = tm.tm_mon;
					mob_month.day.value = 1;

					//OLM_T( LMT_User06, ("Month being processed: '%s'\n", mob_month.str().c_str() ));
					// save month for further occasions
					writer->emit(2, &mob_month, &void_data );
					hasMonth = true;
				}

				//OLM_T(LMT_User06, ("For cdr.phone:%lu emits cdr with cellId:%lu", cdr.phone.value, cellId.value));
				writer->emit(0, &cellId, &cdr );
			}
			//OLM_T(LMT_User06, ("Ends run for key:%lu with cdrs: inputs[1].num_kvs:%lu\n", key.value, inputs[1].num_kvs));
		}
	}

	void finish(samson::KVWriter *writer )
	{
		//OLM_T(LMT_User06, ("reduce_cdr_clients::finish() with 0x%0x\n", this));
	}



};


} // end of namespace samson
} // end of namespace mob

#endif
