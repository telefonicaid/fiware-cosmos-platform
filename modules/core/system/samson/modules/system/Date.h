
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this data
 */

#ifndef _H_SAMSON_system_Date
#define _H_SAMSON_system_Date


#include <samson/modules/system/Date_base.h>
#include <iostream>
#include <iomanip>


namespace samson{
namespace system{


class Date : public Date_base
{
public:
	bool operator== (Date& date) {

		if( day.value	!= date.day.value)		return false;
		if( month.value	!= date.month.value)	return false;
		if( year.value	!= date.year.value)		return false;

		return true;
	}
	bool operator!= (Date& date) {

		if( day.value	!= date.day.value)		return true;
		if( month.value	!= date.month.value)	return true;
		if( year.value	!= date.year.value)		return true;

		return false;
	}

	std::string str(){
		std::ostringstream o;
		o << std::setw(2) << std::setfill('0') << (int) day.value;
		o << "/";
		o << std::setw(2) << std::setfill('0') << (int) month.value;
		o << "/";
		o << std::setw(2) << std::setfill('0') << (int) (2000 + year.value);
		if (week_day_GetAssigned())
		{
			o << "(" << (int)week_day.value << ")";
		}
		return o.str();
	}


	// week_day from 0 to 6, starting on Sunday
	// same as in TimeUnix, tm_wday starts on Sunday
	// 0 -> Sunday
	// 1 -> Monday
	// 2 -> Tuesday
	// 3 -> Wednesday
	// 4 -> Thursday
	// 5 -> Friday
	// 6 -> Saturday

	void compute_day_of_the_week()
	{
		tm tm_original;

		tm_original.tm_hour = 12;
		tm_original.tm_min = 0;
		tm_original.tm_sec = 0;

		tm_original.tm_mday = day.value;
		tm_original.tm_mon = month.value - 1;	// Range 0-11

		if( year.value < 64 )
			tm_original.tm_year = 2000 + year.value - 1900;
		else
			tm_original.tm_year = 1900 + year.value - 1900;

		time_t t = mktime(&tm_original);

		tm result;
		gmtime_r(&t, &result);


		week_day.value = result.tm_wday;

		week_day_SetAssigned(true);
	}


	int daysFrom2000_01_01()
	{
		/* As a side effect, computes and stores the days_2000 and week_day fields */

		if (days_2000_GetAssigned())
		{
			return days_2000.value;
		}
		int duration_days = int(day.value);
		int offsetBisiesto = 0;

#ifdef CALCULO_EXACTO
		if ((year.value%4 == 0) && ((year.value%100 != 0) || (year.value%400 == 0)))
#else
			// OK if we start from 2000 year, and expect to last no more than one 99 years
			if (year.value%4 == 0)
#endif // de CALCULO_EXACTO
			{
				offsetBisiesto = 1;
			}

		switch (month.value)
		{
		case 1:
			break;
		case 2:
			duration_days += 31;
			break;
		case 3:
			duration_days += 59 + offsetBisiesto;
			break;
		case 4:
			duration_days += 90 + offsetBisiesto;
			break;
		case 5:
			duration_days += 120 + offsetBisiesto;
			break;
		case 6:
			duration_days += 151 + offsetBisiesto;
			break;
		case 7:
			duration_days += 181 + offsetBisiesto;
			break;
		case 8:
			duration_days += 212 + offsetBisiesto;
			break;
		case 9:
			duration_days += 243 + offsetBisiesto;
			break;
		case 10:
			duration_days += 273 + offsetBisiesto;
			break;
		case 11:
			duration_days += 304 + offsetBisiesto;
			break;
		case 12:
			duration_days += 334 + offsetBisiesto;
			break;
		}
		//const int YEAR_2000 = 2000;
		const int DAYS_PER_YEAR = 365;
		//const int SECS_PER_DAY = 86400;

		duration_days += DAYS_PER_YEAR * (year.value) + ((year.value - 1) / 4);

		days_2000.value = duration_days;

		days_2000_SetAssigned(true);

		if (week_day_GetAssigned() == false)
		{

			const int DAYS_PER_WEEK = 7;
			const int DAYWEEK_20000101 = 6; // The 01-01-2000 was Saturday; we take Sunday as 0

			week_day.value = (duration_days + DAYWEEK_20000101)%DAYS_PER_WEEK;

			week_day_SetAssigned(true);
		}

		return duration_days;
	}

	/**
	 * Get the number of days of a month.
	 *
	 */
	unsigned int GetMonthDays()
	{
		unsigned int _month = month.value;
		unsigned int _year = year.value + 2000;
		unsigned int _monthDays = 0;



		if( _month == 1 || _month == 3 || _month == 5 || _month == 7 || _month == 8 || _month == 10 || _month == 12)
		{
			_monthDays = 31;
		}
		else if( _month == 2 )
		{
			// Check for leap year
			if( (_year % 4) == 0 )
			{
				// If date is divisible by 400, it's a leap year.
				// Otherwise, if it's divisible by 100 it's not.
				if( (_year % 400) == 0 )
				{
					_monthDays = 29;
				}
				else if( (_year % 100) == 0 )
				{
					_monthDays = 28;
				}
				else
				{
					// Divisible by 4 but not by 100 or 400
					// so it leaps
					_monthDays = 29;
				}
			}
			else
			{
				// Not a leap year
				_monthDays = 28;
			}
		}
		else
		{
			_monthDays = 30;
		}

		return _monthDays;
	}

	void setFromStr(const char *strDate)
	{

#define Char_to_int(x) ((x)-48)
        if (strchr(strDate, '/') != NULL)
        {
            // DD/MM/YY
            year.value = 100 + Char_to_int( strDate[8] )*10 + Char_to_int( strDate[9] );
            month.value = Char_to_int( strDate[3] )*10 + Char_to_int( strDate[4] ) - 1;
            day.value = Char_to_int( strDate[0] )*10 + Char_to_int( strDate[1] );
        }
        else
        {
            // YYMMDD
            year.value = 100 + Char_to_int( strDate[2] )*10 + Char_to_int( strDate[3] );
            month.value = Char_to_int( strDate[4] )*10 + Char_to_int( strDate[5] ) - 1;
            day.value = Char_to_int( strDate[6] )*10 + Char_to_int( strDate[7] );
        }
#undef Char_to_int
	}


    void setFromStr_month_letters(const char *strDate)
    {
        const char *p_month;

#define Char_to_int(x) ((x)-48)
        if (strchr(strDate, '/') != NULL)
        {
            // DD/MMM/YYYY
            year.value = 100 + Char_to_int( strDate[9] )*10 + Char_to_int( strDate[10] );
            p_month = &(strDate[3]);
          day.value = Char_to_int( strDate[0] )*10 + Char_to_int( strDate[1] );
        }
        else
        {
            // YYYYMMMDD
            year.value = 100 + Char_to_int( strDate[2] )*10 + Char_to_int( strDate[3] );
            p_month = &(strDate[4]);
            day.value = Char_to_int( strDate[7] )*10 + Char_to_int( strDate[8] );
        }

        if (strncmp(p_month, "JAN", strlen("JAN")) == 0)
        {
            month.value = 1;
        }
        else if (strncmp(p_month, "FEB", strlen("FEB")) == 0)
        {
            month.value = 2;
        }
        else if (strncmp(p_month, "MAR", strlen("MAR")) == 0)
        {
            month.value = 3;
        }
        else if (strncmp(p_month, "APR", strlen("APR")) == 0)
        {
            month.value = 4;
        }
        else if (strncmp(p_month, "MAY", strlen("MAY")) == 0)
        {
            month.value = 5;
        }
        else if (strncmp(p_month, "JUN", strlen("JUN")) == 0)
        {
            month.value = 6;
        }
        else if (strncmp(p_month, "JUL", strlen("JUL")) == 0)
        {
            month.value = 7;
        }
        else if (strncmp(p_month, "AUG", strlen("AUG")) == 0)
        {
            month.value = 8;
        }
        else if (strncmp(p_month, "SEP", strlen("SEP")) == 0)
        {
            month.value = 9;
        }
        else if (strncmp(p_month, "OCT", strlen("OCT")) == 0)
        {
            month.value = 10;
        }
        else if (strncmp(p_month, "NOV", strlen("NOV")) == 0)
        {
            month.value = 11;
        }
        else if (strncmp(p_month, "DEC", strlen("DEC")) == 0)
        {
            month.value = 12;
        }

#undef Char_to_int
    }

};


} // end of namespace samson
} // end of namespace system

#endif
