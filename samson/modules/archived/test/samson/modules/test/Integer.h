/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this data
*/

#ifndef _H_SAMSON_test_Integer
#define _H_SAMSON_test_Integer

#include <cstdlib>
#include <sstream>

namespace samson{
namespace test{


	class Integer : public samson::DataInstance{
		
	public:

                int value;
		
		Integer() : samson::DataInstance(){

		}
		
		~Integer() {

		}
		
		int parse(char *data){
		  memcpy( &value , data , sizeof( value ) );
		  return sizeof(value);
		}
		
		int serialize(char *data){
		  memcpy( data , &value, sizeof( value ) );
		  return sizeof(value);
		}
		
		int hash(int max_num_partitions)
		{
		  
		  return abs(value)%max_num_partitions;
	        }

		static int size(char *data){
		  return sizeof(int);
		}
		
		inline static int compare(char * data1 , char *data2 , size_t *offset1 , size_t *offset2 )
		{
		  int v1,v2;
		  memcpy( &v1 , data1+*offset1 , sizeof(v1) );
		  memcpy( &v2 , data2+*offset2 , sizeof(v2) );

		  *offset1+=sizeof(v1);
		  *offset2+=sizeof(v2);

		  if ( v1 < v2 )
		    return -1;
		  if ( v1 > v2 )
		    return 1;
		  return 0;
		}
		
		inline static int compare( char* data1 , char* data2 )
		{
			size_t offset_1=0;
			size_t offset_2=0;
			return compare( data1 , data2 , &offset_1 , &offset_2 );
		}
		
		void copyFrom( Integer *other ){
			value = other->value;
		};
		
		std::string str(){
		  std::ostringstream o;
		  o << value;
		  return o.str();
		}
		
	}; 	


} // end of namespace samson
} // end of namespace test

#endif
