/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_wiki_reduce_inverted_index
#define _H_SAMSON_wiki_reduce_inverted_index

#include "logMsg/logMsg.h"
#include <samson/module/samson.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/StringVector.h>
#include <stdint.h>


namespace samson{
namespace wiki{


class reduce_inverted_index : public samson::Reduce
{
	// Input
	samson::system::String word;
	samson::system::String page;

	// State
	samson::wiki::WordInfo wordInfo;

public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.String system.String
	input: system.String wiki.WordInfo
	output: system.String wiki.WordInfo

	helpLine: Builds an inverted index (words or links)
#endif // de INFO_COMMENT

	void init(samson::KVWriter *writer )
	{
		//OLM_T(LMT_User06, ("reduce_inverted_index: init"));
		//LM_M(("reduce_inverted_index: init"));
	}

	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		samson::system::String prevPage;
		samson::system::UInt prevCount;
		int index;

		//LM_M(("inputs[1].num_kvs:%lu", inputs[1].num_kvs));
		if (inputs[1].num_kvs > 0)
		{
			// There is an entry in the state
			word.parse(inputs[1].kvs[0]->key);
			wordInfo.parse(inputs[1].kvs[0]->value);
		}
		else
		{
			// First appearance of key
			word.parse(inputs[0].kvs[0]->key);
			wordInfo.page.valuesSetLength(0);
			wordInfo.count.valuesSetLength(0);
			wordInfo.totalCount.value = 0;
		}
		//OLM_T(LMT_User06, ("key_word:'%s', num_pages:%d, inputs[0].num_kvs:%lu, inputs[1].num_kvs:%lu\n", word.value.c_str(), wordInfo.page.values_length, inputs[0].num_kvs, inputs[1].num_kvs));
		//LM_M(("key_word:'%s', num_pages:%d, inputs[0].num_kvs:%lu, inputs[1].num_kvs:%lu\n", word.value.c_str(), wordInfo.page.values_length, inputs[0].num_kvs, inputs[1].num_kvs));

		if (inputs[0].num_kvs > 0)
		{
			prevPage.parse(inputs[0].kvs[0]->value);
			prevCount.value = 1;

			for (uint64_t i = 1; (i < inputs[0].num_kvs); i++)
			{
				page.parse(inputs[0].kvs[i]->value);

				if (prevPage.value.compare(page.value) == 0)
				{
					prevCount.value++;
				}
				else
				{
					if ((index = wordInfo.page.findIndexSortedFromEnd(prevPage)) == -1)
					{
						//OLM_T(LMT_User06, ("word:'%s', add page:'%s', count:%lu\n", word.value.c_str(), prevPage.value.c_str(), prevCount.value));
						//LM_M(("word:'%s', add page:'%s', count:%lu\n", word.value.c_str(), prevPage.value.c_str(), prevCount.value));

						//wordInfo.page.valuesAdd()->copyFrom(&prevPage);
						//wordInfo.count.valuesAdd()->copyFrom(&prevCount);
						int indexInsert = wordInfo.page.valuesAddSortedFromEnd(prevPage);
						//LM_M(("word:'%s', added page:'%s' at indexInsert:%d\n", word.value.c_str(), prevPage.value.c_str(), indexInsert));

						wordInfo.count.valuesAddAtIndex(prevCount, indexInsert);
					}
					else
					{
						//OLM_T(LMT_User06, ("word:'%s', found page:'%s' at index:%d, count:%lu\n", word.value.c_str(), prevPage.value.c_str(), index, prevCount.value));
						//LM_M(("word:'%s', found page:'%s' at index:%d, count:%lu\n", word.value.c_str(), prevPage.value.c_str(), index, prevCount.value, index));

						wordInfo.totalCount.value -= wordInfo.count.values[index].value;
						wordInfo.count.values[index].value = prevCount.value;
					}
					wordInfo.totalCount += prevCount.value;
					prevPage = page;
					prevCount.value = 1;
				}
			}
			if ((index = wordInfo.page.findIndexSortedFromEnd(prevPage)) == -1)
			{
				//OLM_T(LMT_User06, ("word:'%s', add page:'%s', count:%lu\n", word.value.c_str(), prevPage.value.c_str(), prevCount.value));
				//LM_M(("word:'%s', add page:'%s', count:%lu\n", word.value.c_str(), prevPage.value.c_str(), prevCount.value, index));

				//wordInfo.page.valuesAdd()->copyFrom(&prevPage);
				//wordInfo.count.valuesAdd()->copyFrom(&prevCount);
				int indexInsert = wordInfo.page.valuesAddSortedFromEnd(prevPage);
				//LM_M(("word:'%s', added page:'%s' at indexInsert:%d\n", word.value.c_str(), prevPage.value.c_str(), indexInsert));

				wordInfo.count.valuesAddAtIndex(prevCount, indexInsert);
			}
			else
			{
				//OLM_T(LMT_User06, ("word:'%s', found page:'%s' at index:%d, count:%lu\n", word.value.c_str(), prevPage.value.c_str(), index, prevCount.value));
				//LM_M(("word:'%s', found page:'%s' at index:%d, count:%lu\n", word.value.c_str(), prevPage.value.c_str(), index, prevCount.value));

				wordInfo.totalCount.value -= wordInfo.count.values[index].value;
				wordInfo.count.values[index].value = prevCount.value;
			}
			wordInfo.totalCount.value += prevCount.value;
		}

		//LM_M(("word:'%s', ready to emit", word.value.c_str()));
		writer->emit(0, &word, &wordInfo);
		//LM_M(("word:'%s', emitted", word.value.c_str()));
	}

	void finish(samson::KVWriter *writer )
	{
		//OLM_T(LMT_User06, ("reduce_inverted_index: finish"));
		//LM_M(("reduce_inverted_index: finish"));
	}



};


} // end of namespace wiki
} // end of namespace samson

#endif
