/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_cdr_sna_parse_cdrs
#define _H_SAMSON_cdr_sna_parse_cdrs


#include <samson/module/samson.h>

#undef DEBUG_FILES
#ifdef DEBUG_FILES
#include <iostream>
#include <fstream>
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

namespace samson{
namespace cdr{


	//Macros to parte CDRs
	#define CHAR_TO_INT(v) (v-48)

	#define GET_CDRS_INIT	int pos=0; int pos_field=0;
	#define GET_CDRS_NEXT_FIELD pos_field=pos; while( line[pos] != '|' ) pos++; line[pos]='\0'; pos++;
	#define GET_CDRS_GET_NUMBER		 atoll( &line[pos_field] );
	
bool parseDate_TME (char *dateTxt, samson::system::Date *date, samson::system::Time *time)
{

        if (strlen(dateTxt) != 17) return false;

	date->unassignAllOptionals();

        date->day.value           = CHAR_TO_INT( dateTxt[0] ) *10 + CHAR_TO_INT( dateTxt[1] );
        date->month.value         = CHAR_TO_INT( dateTxt[3] ) *10 + CHAR_TO_INT( dateTxt[4] );
        date->year.value          = CHAR_TO_INT( dateTxt[6] ) *10 + CHAR_TO_INT( dateTxt[7] );

        time->hour.value          = CHAR_TO_INT( dateTxt[9] ) *10 + CHAR_TO_INT( dateTxt[10] );
        time->minute.value        = CHAR_TO_INT( dateTxt[12] ) *10 + CHAR_TO_INT( dateTxt[13] );
        time->seconds.value       = CHAR_TO_INT( dateTxt[15] ) *10 + CHAR_TO_INT( dateTxt[16] );

        return true;
}

bool parseDate_O2UK (char *dateTxt, samson::system::Date *date, samson::system::Time *time)
{
        if (strlen(dateTxt) != 14)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
		{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing Date:" << dateTxt << " strlen: " << strlen(dateTxt) << std::endl;
                fs.close();
		}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        const int YEAR_2000 = 2000;

	date->unassignAllOptionals();

        date->year.value          = (CHAR_TO_INT( dateTxt[0] ) *1000 + CHAR_TO_INT( dateTxt[1] ) *100 + CHAR_TO_INT( dateTxt[2] ) *10 + CHAR_TO_INT( dateTxt[3] )) - YEAR_2000;
        date->month.value         = CHAR_TO_INT( dateTxt[4] ) *10 + CHAR_TO_INT( dateTxt[5] );
        date->day.value           = CHAR_TO_INT( dateTxt[6] ) *10 + CHAR_TO_INT( dateTxt[7] );


        time->hour.value          = CHAR_TO_INT( dateTxt[8] ) *10 + CHAR_TO_INT( dateTxt[9] );
        time->minute.value        = CHAR_TO_INT( dateTxt[10] ) *10 + CHAR_TO_INT( dateTxt[11] );
        time->seconds.value       = CHAR_TO_INT( dateTxt[12] ) *10 + CHAR_TO_INT( dateTxt[13] );
        return true;
}


int secsFrom2000_01_01(samson::system::Date *date, samson::system::Time *time)
{
        int duration_secs = time->seconds.value + 60 * time->minute.value + 3600 * time->hour.value;

        int duration_days = date->daysFrom2000_01_01(); // As a side effect, computes and stores the days_2000 and week_day fields

        const int SECS_PER_DAY = 86400;

        duration_secs += SECS_PER_DAY * duration_days;

        return (duration_secs);
}
	
	bool getCDRFromLine_TME( char *line, samson::system::UInt* node, samson::cdr::CDR * cdr )
	{
		//LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"	
		//Note: multihtread save implementation
		
		GET_CDRS_INIT
		
		GET_CDRS_NEXT_FIELD		
		//First field useless
		
		GET_CDRS_NEXT_FIELD
		*node = (size_t) GET_CDRS_GET_NUMBER;
		
		GET_CDRS_NEXT_FIELD
		cdr->node = (size_t) GET_CDRS_GET_NUMBER;
		
		
		GET_CDRS_NEXT_FIELD
		cdr->date.day.value		= CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month.value		= CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year.value		= CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );
		
		cdr->time.hour.value		= CHAR_TO_INT( line[pos_field+9] ) *10 + CHAR_TO_INT( line[pos_field+10] );
		cdr->time.minute.value	= CHAR_TO_INT( line[pos_field+12] ) *10 + CHAR_TO_INT( line[pos_field+13] );
		cdr->time.seconds.value	= CHAR_TO_INT( line[pos_field+15] ) *10 + CHAR_TO_INT( line[pos_field+16] );
		
		GET_CDRS_NEXT_FIELD
		cdr->duration = (size_t) GET_CDRS_GET_NUMBER;
		
		
		//Global Checking...
		if(cdr->node <= 0)				return false;
		if(node->value <= 0)			return false;
		if(node->value == cdr->node.value)	return false;
		
		return true;
	}
	
bool getCDRFromLine_O2UK_p2p( char *line, samson::system::UInt* node, samson::cdr::CDR * cdr)
{
        //LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
        //Note: multihtread save implementation

        const int nMaxFields=134;
        const int lMaxField=64;
        char field[nMaxFields][lMaxField];
        int nField = 0;
        int nTotalFields = 0;

        char *pField = line;
        char *pSep;

        while((pSep = strchr(pField, '|')) != NULL)
        {
                if (nField >= nMaxFields)
                {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                if ((pSep - pField) > (lMaxField - 1))
                {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; field: " << nField << " longer than lMaxField: " << lMaxField << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                else
                {
                        *pSep = '\0';
                        strcpy(field[nField], pField);
                        nField++;
                        *pSep = '|';
                        pField = pSep+1;
                }
        }
        if (nField >= nMaxFields)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        strcpy(field[nField], pField);
        nTotalFields = nField+1;

        //Fields of interest (for mms type file):
        //18: Calling ID
        //24: Called ID
        //29: Submit Date
        //4: Done Date

        const int CALLING_ID_FIELD = 18;
        const int CALLED_ID_FIELD = 24;
        const int SUBMIT_DATE_FIELD = 29;
        const int DONE_DATE_FIELD = 4;


        *node = (size_t) atoll(field[CALLING_ID_FIELD - 1]);
        cdr->node = (size_t) atoll(field[CALLED_ID_FIELD - 1]);

        char *pDateSubmit = field[SUBMIT_DATE_FIELD - 1];
        char *pDateDone = field[DONE_DATE_FIELD - 1];
        samson::system::Date dateDone;
        samson::system::Time timeDone;

        if (!parseDate_O2UK(pDateSubmit, &(cdr->date), &(cdr->time)))
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateSubmit" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        if (!parseDate_O2UK(pDateDone, &(dateDone), &(timeDone)))
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateDone" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        int secsSubmit = secsFrom2000_01_01(&(cdr->date), &(cdr->time));
        int secsDone = secsFrom2000_01_01(&(dateDone), &(timeDone));

        cdr->duration = secsDone - secsSubmit;

        if (cdr->duration < 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing duration: " << cdr->duration.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        //Global Checking...
        if(cdr->node <= 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing cdr->node: " << cdr->node.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value <= 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value == cdr->node.value)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << " == " << cdr->node.value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }

        return true;
}

bool getCDRFromLine_O2UK_smsc( char *line, samson::system::UInt* node, samson::cdr::CDR * cdr)
{
        //LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
        //Note: multihtread save implementation

        const int nMaxFields=134;
        const int lMaxField=64;
        char field[nMaxFields][lMaxField];
        int nField = 0;
        int nTotalFields = 0;

        char *pField = line;
        char *pSep;

        while((pSep = strchr(pField, '|')) != NULL)
        {
                if (nField >= nMaxFields)
                {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                if ((pSep - pField) > (lMaxField - 1))
                {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; field: " << nField << " longer than lMaxField: " << lMaxField << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                else
                {
                        *pSep = '\0';
                        strcpy(field[nField], pField);
                        nField++;
                        *pSep = '|';
                        pField = pSep+1;
                }
        }
        if (nField >= nMaxFields)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        strcpy(field[nField], pField);
        nTotalFields = nField+1;

        //Fields of interest (for mms type file):
        //7: Calling ID
        //8: Called ID
        //15: Submit Date
        //17: Done Date

        const int CALLING_ID_FIELD = 7;
        const int CALLED_ID_FIELD = 8;
        const int SUBMIT_DATE_FIELD = 15;
        const int DONE_DATE_FIELD = 17;


        *node = (size_t) atoll(field[CALLING_ID_FIELD - 1]);
        cdr->node = (size_t) atoll(field[CALLED_ID_FIELD - 1]);

        char *pDateSubmit = field[SUBMIT_DATE_FIELD - 1];
        char *pDateDone = field[DONE_DATE_FIELD - 1];
        samson::system::Date dateDone;
        samson::system::Time timeDone;

        if (!parseDate_O2UK(pDateSubmit, &(cdr->date), &(cdr->time)))
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateSubmit" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        if (!parseDate_O2UK(pDateDone, &(dateDone), &(timeDone)))
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateDone" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        int secsSubmit = secsFrom2000_01_01(&(cdr->date), &(cdr->time));
        int secsDone = secsFrom2000_01_01(&(dateDone), &(timeDone));

        cdr->duration = secsDone - secsSubmit;

        if (cdr->duration < 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing duration: " << cdr->duration.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        //Global Checking...
        if(cdr->node <= 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing cdr->node: " << cdr->node.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value <= 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value == cdr->node.value)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << " == " << cdr->node.value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }

        return true;
}
bool getCDRFromLine_O2UK_mms( char *line, samson::system::UInt* node, samson::cdr::CDR * cdr)
{
        //LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
        //Note: multihtread save implementation

        const int nMaxFields=134;
        const int lMaxField=64;
        char field[nMaxFields][lMaxField];
        int nField = 0;
        int nTotalFields = 0;

        char *pField = line;
        char *pSep;

        while((pSep = strchr(pField, '|')) != NULL)
        {
                if (nField >= nMaxFields)
                {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                if ((pSep - pField) > (lMaxField - 1))
                {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; field: " << nField << " longer than lMaxField: " << lMaxField << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                else
                {
                        *pSep = '\0';
                        strcpy(field[nField], pField);
                        nField++;
                        *pSep = '|';
                        pField = pSep+1;
                }
        }
        if (nField >= nMaxFields)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        strcpy(field[nField], pField);
        nTotalFields = nField+1;

        //Fields of interest (for mms type file):
        //9: Calling ID
        //11: Called ID
        //unknown: Submit Date
        //unknown: Done Date

        const int CALLING_ID_FIELD = 9;
        const int CALLED_ID_FIELD = 11;
        //const int SUBMIT_DATE_FIELD = 29;
        //const int DONE_DATE_FIELD = 4;


        char *psep;
        if ((psep = strchr(field[CALLING_ID_FIELD - 1], '\\')) != NULL)
        {
                *psep = '\0';
        }
        if ((psep = strchr(field[CALLING_ID_FIELD - 1], '\\')) != NULL)
        {
                *psep = '\0';
        }

        *node = (size_t) atoll(field[CALLING_ID_FIELD - 1]);
        cdr->node = (size_t) atoll(field[CALLED_ID_FIELD - 1]);

#ifdef DATES_KNOWN
        char *pDateSubmit = field[SUBMIT_DATE_FIELD - 1];
        char *pDateDone = field[DONE_DATE_FIELD - 1];
        samson::system::Date dateDone;
        samson::system::Time timeDone;

        if (!parseDate_O2UK(pDateSubmit, &(cdr->date), &(cdr->time)))
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateSubmit" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        if (!parseDate_O2UK(pDateDone, &(dateDone), &(timeDone)))
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateDone" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        int secsSubmit = secsFrom2000_01_01(&(cdr->date), &(cdr->time));
        int secsDone = secsFrom2000_01_01(&(dateDone), &(timeDone));

        cdr->duration = secsDone - secsSubmit;

        if (cdr->duration < 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing duration: " << cdr->duration.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
#endif /* de DATE_KNOWN */
#undef DEBUG_FILES

        //Global Checking...
        if(cdr->node <= 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing cdr->node: " << cdr->node.toInt() << "field:'" << field[CALLED_ID_FIELD - 1] << "'" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value <= 0)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << "field:'" << field[CALLING_ID_FIELD - 1] << "'" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value == cdr->node.value)
        {
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << " == " << cdr->node.value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }

        return true;
}

	
	class parse_cdrs : public samson::Parser
	{

	public:

		samson::system::UInt node;	// Main telephone number
		samson::cdr::CDR cdr;		// All information related with this
		
		void run( char *data , size_t length , samson::KVWriter *writer )
		{
			
			size_t line_begin = 0;
			size_t offset = 0;
			enum CDRsSources { TME, O2UKsmsc, O2UKmms, O2UKp2p };
			CDRsSources codSource = TME;

			std::string source = environment->get( "cdr.CDRs_source", "TME");
			
#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str());
                fs << "Detected source: " << source << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

			if (!source.compare("TME"))
			{
				codSource = TME;
			}
			else if (!source.compare("O2UKsmsc"))
			{
				codSource = O2UKsmsc;
			}
			else if (!source.compare("O2UKmms"))
			{
				codSource = O2UKmms;
			}
			else if (!source.compare("O2UKp2p"))
			{
				codSource = O2UKp2p;
			}


#undef DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str());
                fs << "Process length: " << length << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

			while( offset < length )
			{
				if( data[offset] == '\n' || data[offset] == '\0' )
				{
					data[offset] = '\0';
					//LM_M(("Process line"));
					
					// Process line
					switch (codSource)
					{
					case TME:
						if( getCDRFromLine_TME( data+line_begin , &node , &cdr ) )
							writer->emit( 0 , &node , &cdr );
						break;
					case O2UKsmsc:
						if( getCDRFromLine_O2UK_smsc( data+line_begin , &node , &cdr ) )
							writer->emit( 0 , &node , &cdr );
						break;
					case O2UKmms:
						if( getCDRFromLine_O2UK_mms( data+line_begin , &node , &cdr ) )
							writer->emit( 0 , &node , &cdr );
						break;
					case O2UKp2p:
						if( getCDRFromLine_O2UK_p2p( data+line_begin , &node , &cdr ) )
							writer->emit( 0 , &node , &cdr );
						break;
					}

					
					line_begin = offset+1;
				}
				
				offset++;
			}
			
			if( line_begin < (length-1) )
			{
				data[length-1] = '\0';
				switch (codSource)
				{
				case TME:
					if( getCDRFromLine_TME( data+line_begin , &node , &cdr ) )
						writer->emit( 0 , &node , &cdr );
					break;
				case O2UKsmsc:
					if( getCDRFromLine_O2UK_smsc( data+line_begin , &node , &cdr ) )
						writer->emit( 0 , &node , &cdr );
					break;
				case O2UKmms:
					if( getCDRFromLine_O2UK_mms( data+line_begin , &node , &cdr ) )
						writer->emit( 0 , &node , &cdr );
					break;
				case O2UKp2p:
					if( getCDRFromLine_O2UK_p2p( data+line_begin , &node , &cdr ) )
						writer->emit( 0 , &node , &cdr );
					break;
				}
				
			}
			
		}
	};

} // end of namespace samson
} // end of namespace cdr

#endif
