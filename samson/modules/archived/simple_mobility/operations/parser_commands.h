/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_simple_mobility_parser_commands
#define _H_SAMSON_simple_mobility_parser_commands


#include <samson/module/samson.h>
#include <samson/modules/system/SimpleParser.h>    // SimpleParser
#include <samson/modules/system/StringVector.h>
#include <samson/modules/system/UInt.h>


namespace samson{
namespace simple_mobility{


   class parser_commands : public samson::system::SimpleParser
	{

	   std::vector<char*> words;    // Vector used to store words parsed at each line

       // Key values used to emit content
	   samson::system::UInt key;
	   samson::system::StringVector value;

	public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

output: system.UInt system.StringVector

helpLine: Parse input txt commands to update internal state of users
#endif // de INFO_COMMENT

		void init( samson::KVWriter *writer )
		{
		}

	   void parseLine( char * line , samson::KVWriter *writer )
	   {
		  // Split line in words
		  split_in_words( line, words );

		  if( words.size() < 2 )
			 return;// No content for a valid instruction
		  

		  // Key
		  std::string key_string = words[0]; // First word is the user-id or a range os used-ids

		  // Values
		  value.valuesSetLength(0);
		  for( size_t i = 1 ; i < words.size() ; i++)
			 value.valuesAdd()->value = words[i];


		  // Look if key is a unique identifier or a range of identifiers
		  size_t div_pos = key_string.find("-");

		  if( div_pos == std::string::npos )
		  {
			 key.value = atoll( key_string.c_str() );
			 writer->emit( 0 , &key , &value );
		  }
		  else
		  {

			 size_t from = atoll( key_string.substr( 0 , div_pos ).c_str() );
			 size_t to = atoll( key_string.substr( div_pos+1 , key_string.length() - (std::string::npos+1)  ).c_str() );
									
			 if( from <= to )
				for( size_t k = from ; k <= to ; k++ )
				{
				   key.value = k;
				   writer->emit( 0 , &key , &value );
				}
		  }
   	  

	   }

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace simple_mobility
} // end of namespace samson

#endif
